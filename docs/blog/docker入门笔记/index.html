<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="站点描述">
<title>
Docker入门笔记（一） - 无名博客
</title>



        
        <meta property="og:title" content="Docker入门笔记（一） - 无名博客" />
<meta property="og:type" content="website" />
<meta property="og:description" content="站点描述"/>
<meta property="og:url" content="https://radish.cloud/blog/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
<meta property="og:site_name" content="无名博客"/>




<meta property="og:image" content="https://radish.cloud/home/mx.jpg"/>




        
<link rel="shortcut icon" href="/img/fav.ico">


        





<link rel="stylesheet" href="/css/main.min.20f701138a49cf7971fe80b1829416789fa588f156b3a6c8c1a09fa03d89a991.css" integrity="sha256-IPcBE4pJz3lx/oCxgpQWeJ&#43;liPFWs6bIwaCfoD2JqZE="
    crossorigin="anonymous" media="screen">






<link rel="stylesheet" href="/css/dino.css">
<script src="/js/dino.js"></script>
<link rel="stylesheet" href="/foo.css" integrity="" crossorigin="anonymous"
    media="screen">
        
        
        
        
    </head>
    <body>
        <section id="top" class="section">
            
            <div class="container hero  fade-in one ">
                

<h1 class="bold-title is-1">博客</h1>


            </div>
            
            <div class="section  fade-in two ">
                
<div class="container">
    <hr>
    <nav class="navbar" role="navigation" aria-label="main navigation">
        
        <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false" >
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
        <div class="navbar-menu " id="navMenu">
            
            
            
            
            <a class="navbar-item" href="/">主页</a>
            

            
            

            
                
            

            
                
            

            
            
            
            
            
            <a class="navbar-item" href="/#about">关于我</a>
            
            
            
            
            
                
                
                
                
                  <a class="navbar-item" href="https://radish.cloud/projects/">
                  
                  
                  项目
                  
                  
                  </a>
                
                
            
            
            
            
            
                
                
                
                
                  <a class="navbar-item" href="https://radish.cloud/blog/">
                  
                  返回到-&gt; 博客
                  
                  </a>
                
                
            
            
            
            
            
            <a class="navbar-item" href="/#links">友情链接</a>
            
            
            
            

            
            
            <a class="navbar-item" href="/#contact">联系我</a>
            
            

            
            
            
            
            <a class="navbar-item" href="https://radish.cloud/en/">English</a>
            
            

            
            <a class="navbar-item" href="https://radish.cloud/index.xml"><i class="fas fa-rss"></i></a>
            
            
        </div>
    </nav>
    <hr>
</div>



                
<div class="container">
    <h2 class="title is-1 top-pad strong-post-title">
        <a href="https://radish.cloud/blog/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">Docker入门笔记（一）</a>
    </h2>
    <div class="post-data">
        May 28, 2018 |
        3 分钟
    </div>
    
    <div class="blog-share">
        分享:
        
        <a class="twitter-share-button" href="https://twitter.com/intent/tweet?text=Docker%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b0%ef%bc%88%e4%b8%80%ef%bc%89%20https%3a%2f%2fradish.cloud%2fblog%2fdocker%25E5%2585%25A5%25E9%2597%25A8%25E7%25AC%2594%25E8%25AE%25B0%2f" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
            <i class="fab fa-twitter"></i>
            <span class="hidden">Twitter</span>
        </a>
        
        
        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fradish.cloud%2fblog%2fdocker%25E5%2585%25A5%25E9%2597%25A8%25E7%25AC%2594%25E8%25AE%25B0%2f" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
            <i class="fab fa-facebook-f"></i>
            <span class="hidden">Facebook</span>
        </a>
        
        
        <a class="icon-pinterest" href="http://pinterest.com/pin/create/button/?url=https%3a%2f%2fradish.cloud%2fblog%2fdocker%25E5%2585%25A5%25E9%2597%25A8%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;description=Docker%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b0%ef%bc%88%e4%b8%80%ef%bc%89" onclick="window.open(this.href, 'pinterest-share','width=580,height=296');return false;">
            <i class="fab fa-pinterest-p"></i>
            <span class="hidden">Pinterest</span>
        </a>
        
    </div>
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
      
     <p>
         Tags: 
          
           <a href="/tags/docker">
             docker</a>,
         
           <a href="/tags/java">
             java</a>
         
        </p>
      
    
      
    
</div>

<div class="container markdown top-pad">
    <p>如今，如果你作为一个开发者而不知道容器化技术，那你可能要反思一下自己了，作为计算机领域发展最快最热门的技术之一，容器成为了现代互联网服务架构的基石。<br>
2013年DotCloud发布了容器服务Docker，并在2015年发布了其第一个正式版本，同年国内的Daocloud和灵雀云等公司开始提供基于docker的云服务业务，正是在此机会下我有幸接触了当时还非常先进的容器化技术（其实我当时对容器化还没有任何概念）。Docker在当时给我留下了最大的印象就是启动快，部署非常快，并且我当时参照daocloud官方提供的教程构建了一些镜像，不过当时的我，只是把Docker作为了一种新奇好玩的玩具，而没有深入的了解和使用。<br>
时间转到今天，随着微服务的兴起，容器化技术已经成为了微服务架构中的重要基石，docker对我来说不再是一个玩具，而是重要的开发部署工具，从今天起，我将重新开始学习docker,并用一系列文章来记录我学习过程。</p>

<h2 id="docker-概述" class="anchor-link"><a href="#docker-%e6%a6%82%e8%bf%b0">Docker 概述</a></h2>

<h3 id="什么是docker" class="anchor-link"><a href="#%e4%bb%80%e4%b9%88%e6%98%afdocker">什么是Docker</a></h3>
<p>虽然Docker及其背后代表的容器化技术已经非常热门了，但是容器化并不是什么新技术，于1979年出现的Chroot Jailb被认为是Dcoker技术的起源，也就是现代Linux系统中的chroot环境，下面列出的一些都是早期的容器服务：</p>
<ul>
<li>Chroot Jail</li>
<li>FreeBSD Jails</li>
<li>Linux VServer</li>
<li>Solaris Containers</li>
<li>OpenVZ</li>
<li>Process Containers</li>
<li>LXC</li>
<li>Warden</li>
<li>LMCTFY</li>
<li>Docker</li>
<li>RKT</li>
</ul>
<p>正如我们所看到的，docker 并不是第一个容器化技术，但它的确是最知名的一个。Docker 诞生于 2013 年，并获得了快速的发展。</p>
<p>所以到底什么是Docker呢？</p>
<p>我们看看书本上的说法：</p>
<blockquote>
<p>Docker使用Google公司推出的Go语言进行开发实现，基于 Linux内核的cgroup，namespace，以及AUFS类的Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于LXC，从0.7以后开始去除LXC，转而使用自行开发的libcontainer，从1.11开始，则进一步演进为使用runC和containerd。<br>
Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
</blockquote>
<p>实际上docker本质上就是一种虚拟化技术，与传统的虚拟化技术不同的是，他没有在虚拟化环境中虚拟出一个完整的操作系统内核，而是将虚拟化环境中的进程放在物理机内核中执行,这就是docker容器化的核心。这种方式使docker具有了很多传统虚拟化方式没有的优势。</p>

<h3 id="为什么选择docker" class="anchor-link"><a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%89%e6%8b%a9docker">为什么选择docker</a></h3>

<h4 id="更高效的利用系统资源" class="anchor-link"><a href="#%e6%9b%b4%e9%ab%98%e6%95%88%e7%9a%84%e5%88%a9%e7%94%a8%e7%b3%bb%e7%bb%9f%e8%b5%84%e6%ba%90">更高效的利用系统资源</a></h4>
<p>由前文我们知道，dcoker容器内的程序本质上就是宿主机上运行的进程，这样就极大减小了性能的损耗，由于不需要模拟内核和周边硬件，也节省了这部分的性能损耗</p>

<h4 id="更快的启动时间" class="anchor-link"><a href="#%e6%9b%b4%e5%bf%ab%e7%9a%84%e5%90%af%e5%8a%a8%e6%97%b6%e9%97%b4">更快的启动时间</a></h4>
<p>docker容器本质就是一个个宿主机内核程序，所以启动较快</p>

<h4 id="运行环境一致性" class="anchor-link"><a href="#%e8%bf%90%e8%a1%8c%e7%8e%af%e5%a2%83%e4%b8%80%e8%87%b4%e6%80%a7">运行环境一致性</a></h4>
<p>Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性</p>

<h4 id="持续交付和部署" class="anchor-link"><a href="#%e6%8c%81%e7%bb%ad%e4%ba%a4%e4%bb%98%e5%92%8c%e9%83%a8%e7%bd%b2">持续交付和部署</a></h4>
<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署(Continuous Delivery/Deployment) 系统进行自动部署。</p>

<h4 id="更轻松的维护和拓展" class="anchor-link"><a href="#%e6%9b%b4%e8%bd%bb%e6%9d%be%e7%9a%84%e7%bb%b4%e6%8a%a4%e5%92%8c%e6%8b%93%e5%b1%95">更轻松的维护和拓展</a></h4>
<p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易</p>

<h2 id="docekr的镜像与容器" class="anchor-link"><a href="#docekr%e7%9a%84%e9%95%9c%e5%83%8f%e4%b8%8e%e5%ae%b9%e5%99%a8">Docekr的镜像与容器</a></h2>
<p>首先我们了解三个Docker的基本概念</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<p>这三个概念组成了Docker的完整生命周期，我们将在下面的过程中详细介绍</p>

<h3 id="环境" class="anchor-link"><a href="#%e7%8e%af%e5%a2%83">环境</a></h3>
<p>如今，Docker可以运行在所有的主流操作系统上，包括Linux，Windows，MacOSX，因为我平时喜欢使用Linux，本文将在Linux上部署和使用，我将使用我的笔记本电脑和一台Daocloud胶囊主机来完成本文的内容</p>
<ul>
<li>本地环境：Manjaro Linux18.0+Docker18.09.0-ce,</li>
<li><del>远程主机环境：Ubuntu14.04+(因为写作到这的时候断网了就放弃远程环境了)</del></li>
</ul>
<p>在Manjaro安装Docker非常简单，在终端输入：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>sudo Pacman -S docker-ce
</code></pre></div><p><del>即可安装，并无需额外配置</del><br>
启动Docker服务</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>systemctl start docker 
</code></pre></div><p>检查Docker版本</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>$ docker --version
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>Docker version 18.09.0-ce, build 4d60db472b
</code></pre></div><p>Docker就安装好了</p>

<h3 id="镜像" class="anchor-link"><a href="#%e9%95%9c%e5%83%8f">镜像</a></h3>
<p>首先我们将了解Docker最核心的概念之一：镜像。镜像是Docker特殊的文件存储形式，其中储存了Linux运行时的用户空间，根据Linux的设计，Linux分为内核和用户空间，宿主机为Docker容器运行提供了内核支持，而Linux镜像为Docker运行提供了用户空间的支持。除了Linux的用户空间外，Docker镜像还储存了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等），Docker镜像不包含任何动态数据，构建完成后不会被改变。</p>
<p>由于docker使用了UnionFS技术，所以Docker实现了分层储存的特性，镜像并非是一个完整的“镜像”文件，而是一种抽象概念，在存储中，Docker镜像根据构建顺序依次完成储存，不同的镜像可以共享其中的中间层，大大减小了Docker镜像的体积。</p>

<h4 id="获取镜像" class="anchor-link"><a href="#%e8%8e%b7%e5%8f%96%e9%95%9c%e5%83%8f">获取镜像</a></h4>
<p>Docker运行前需要对应的镜像，所以我们可以从镜像仓库拉取镜像，Docker默认的镜像仓库是DockerHub，其中内置了大量高质量的Dokcer基础镜像，我们也可以将自己的镜像发布至DockerHub</p>
<blockquote>
<p>前文我们提到了仓库（Repository）的概念，仓库是一个集中存储和分发镜像的服务，一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。我们可以部署只自己仓库，也可以使用公共的仓库服务。</p>
</blockquote>
<p>获取镜像使用<code>docker pull</code>命令：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>docker pull <span style="color:#f92672">[</span>选项<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>Docker Registry地址<span style="color:#f92672">]</span>&lt;仓库名&gt;:&lt;标签&gt;
</code></pre></div><p>如没有仓库地址名，将使用默认的仓库。
例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span>$ sudo docker pull node:latest
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>latest: Pulling from library/node
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span>54f7e8ac135a: Already exists 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span>d6341e30912f: Already exists 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>087a57faf949: Already exists 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>5d71636fb824: Pull complete 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>0c1db9598990: Pull complete 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>89669bc2deb2: Pull complete 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>647616206038: Pull complete 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>64f67f03205b: Pull complete 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>Digest: sha256:fed3f48ec9e97a57c17977ff120c3e7bf7d2d4e930ef650bba3f2ada5ac4a33a
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>Status: Downloaded newer image for node:latest
</code></pre></div><p>这个命令将在Docker的中央仓库下载一个最新版本的Nodejs镜像</p>

<h4 id="列出镜像" class="anchor-link"><a href="#%e5%88%97%e5%87%ba%e9%95%9c%e5%83%8f">列出镜像</a></h4>
<p>我们可以使用<code>docker images</code>列出所有本地的镜像</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>$ docker images
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>docker-test                       0.0.1               ce25b22437c5        9 days ago          443MB
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>node                              latest              37f455de4837        9 days ago          894MB
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>tomcat                            latest              48dd385504b1        9 days ago          475MB
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>ubuntu                            latest              93fd78260bd1        3 weeks ago         86.2MB
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span>fabric8/java-jboss-openjdk8-jdk   1.2.3               7a2a8001c977        23 months ago       422MB
</code></pre></div><p>列表包含了仓库名、标签、镜像 ID、创建时间以及所占用的空间。</p>
<p>docker分层构建的方式产生了大量的中间层镜像，docker默认只显示最外层的镜像，我们可以通过以下命令查看</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>$ docker images -a 
</code></pre></div><p>此外<code>docker images</code>还可以通过一些条件来查看镜像：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#75715e"># 查看特定仓库名的镜像</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>$ sudo docker images ubuntu 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span>ubuntu              latest              93fd78260bd1        <span style="color:#ae81ff">3</span> weeks ago         86.2MB
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span style="color:#75715e"># 使用过滤器查看镜像</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span style="color:#75715e"># 从某个镜像开始的所有镜像</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>sudo docker images -f since<span style="color:#f92672">=</span>ubuntu
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#75715e"># 查看特点标签的镜像</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>docker images -f label<span style="color:#f92672">=</span>com.example.version<span style="color:#f92672">=</span>0.1
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span style="color:#75715e"># 使用Go语言模板制定输出格式</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>$ docker images --format <span style="color:#e6db74">&#34;table {{.ID}}\t{{.Repository}}\t{{.Tag
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span style="color:#e6db74">}}&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>
</code></pre></div>
<h4 id="删除镜像" class="anchor-link"><a href="#%e5%88%a0%e9%99%a4%e9%95%9c%e5%83%8f">删除镜像</a></h4>
<p>当我们不需要某个镜像的时候，我们可以选择删除镜像，使用<code>docker rmi</code>命令即可删除镜像
例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>$ sudo docker rmi tomcat:latest
</code></pre></div>
<h4 id="构建镜像" class="anchor-link"><a href="#%e6%9e%84%e5%bb%ba%e9%95%9c%e5%83%8f">构建镜像</a></h4>
<p>使用DockerFile构建镜像将在下一篇文章中详细展开</p>

<h3 id="容器" class="anchor-link"><a href="#%e5%ae%b9%e5%99%a8">容器</a></h3>
<p>如果你熟悉面向对象的开发的话，你可能更容易理解镜像与容器之间的关系。镜像就是面向对象中的类，而容器就是实例，容器就是实例化的镜像，容器是动态的。如前文所述，容器的实质是宿主机中的进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间,容器内的进程是隔离与宿主机环境的。</p>

<h4 id="运行" class="anchor-link"><a href="#%e8%bf%90%e8%a1%8c">运行</a></h4>
<p>当我们有了镜像之后，我们就可以运行我们的镜像并建立新的容器（实例）,docker使用<code>docker run</code> 命令来运行容器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>$ sudo docker run -it --rm ubuntu /bin/bash    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span>root@d332f4d5aecb:/# cat /etc/os-release 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span>NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Ubuntu&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>VERSION<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;18.04.1 LTS (Bionic Beaver)&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>ID<span style="color:#f92672">=</span>ubuntu
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>ID_LIKE<span style="color:#f92672">=</span>debian
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>PRETTY_NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Ubuntu 18.04.1 LTS&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>VERSION_ID<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;18.04&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>HOME_URL<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;https://www.ubuntu.com/&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>SUPPORT_URL<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;https://help.ubuntu.com/&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>BUG_REPORT_URL<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;https://bugs.launchpad.net/ubuntu/&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>PRIVACY_POLICY_URL<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>VERSION_CODENAME<span style="color:#f92672">=</span>bionic
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>UBUNTU_CODENAME<span style="color:#f92672">=</span>bionic
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>root@d332f4d5aecb:/# exit
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>exit
</code></pre></div><ul>
<li>&ndash;it ：这是两个参数，一个是 -i ：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终获取镜像终端。</li>
<li>&ndash;rm ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 &ndash;rm 可以避免浪费空间。</li>
<li>ubuntu:14.04 ：这是指用 ubuntu:14.04 镜像为基础来启动容器。
/bin/bash ：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash 。</li>
</ul>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载
启动</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>我们可以使用<code>-d</code>参数使容器在后台运行，例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>$ sudo docker run -d ubuntu /bin/sh -c &#34;while true; do echo hello world; sleep 1; done&#34;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
</code></pre></div><p>使用<code>docker ps</code> 可以查看docker容器运行状态</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>$ sudo docker ps
</code></pre></div><p>希望获取docker日志信息</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>docker logs 77b2dc01
</code></pre></div>
<h4 id="终止容器" class="anchor-link"><a href="#%e7%bb%88%e6%ad%a2%e5%ae%b9%e5%99%a8">终止容器</a></h4>
<p>当我们需要终止容器时可以使用<code>docker stop</code> 命令,当容器z中的应用终止时，容器也会自动终止，可以使用<code>docker ps -a </code>查看中止的容器，终止的容器可以用<code>docker start</code>来重新启动,同理，<code>docker restart</code> 将会将容器重启</p>

<h4 id="删除容器" class="anchor-link"><a href="#%e5%88%a0%e9%99%a4%e5%ae%b9%e5%99%a8">删除容器</a></h4>
<p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。 例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>$sudo docker rm trusting_newton
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>trusting_newton
</code></pre></div><p>如果要删除一个运行中的容器，可以添加<code>-f</code>参数。Docker 会发送 <code>SIGKILL</code>
信号给容器。</p>
<p>使用如下命令可以终结全部处于终止状态的容器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>docker rm $(docker ps -a -q)
</code></pre></div>
<h4 id="其他操作" class="anchor-link"><a href="#%e5%85%b6%e4%bb%96%e6%93%8d%e4%bd%9c">其他操作</a></h4>

<h5 id="导出容器" class="anchor-link"><a href="#%e5%af%bc%e5%87%ba%e5%ae%b9%e5%99%a8">导出容器</a></h5>
<p>如果要导出本地某个容器，可以使用 <code>docker export </code> 命令。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>$ sudo docker export 3f6&gt;java.tar
</code></pre></div>
<h4 id="导入容器" class="anchor-link"><a href="#%e5%af%bc%e5%85%a5%e5%ae%b9%e5%99%a8">导入容器</a></h4>
<p>导出的本地镜像可以用<code>docker import</code>命令来导入</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0
</code></pre></div><p>下一篇文章，我们讲讲解docker构建镜像的常见方式</p>
<blockquote>
<p>参考<br>
<a href="https://d.ljmx.top/Docker%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%2B%E7%AC%AC2%E7%89%88.pdf">杨保华,戴王剑，曹亚伦-Docker技术入门与实战第二版</a><br>
<a href="https://www.cnblogs.com/along21/p/9183609.html">alonghub-Docker的发展历程</a></p>
</blockquote>

</div>




<section class="comments">
<script src="https://utterances.radish.cloud/client.js"
        repo="Lairdkin/blog"
        issue-term="pathname"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>

</section>



                
                <div class="container">
    <hr>
</div>
<div class="container has-text-centered top-pad">
    <a href="#top">
        <i class="fa fa-arrow-up"></i>
    </a>
</div>

<div class="container">
    <hr>
</div>

                <div class="section" id="footer">
    <div class="container has-text-centered">
    
        <span class="footer-text">
            © 2017-2021 萝卜炖鱼丸 | 蒙ICP备14003205号-2 | <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh"><strong>CC BY-SA 4.0</strong></a> 许可</br> 站点部署于<a href="https://pages.github.com/"><strong>GIthub Pages</strong></a>，由<a href="cloudflare.com"><strong>Cloudflare</strong></a>提供加速</br> <a href="https://github.com/victoriadrake/hugo-theme-introduction/"><strong>Introduction</strong></a> 主题为 <a href="http://gohugo.io/">Hugo</a> 而设。由开源社群贡献者以 <a href="https://victoria.dev"><i class="fa fa-heart"></i> 和 <i class="fa fa-coffee"></i></a> 创造。
        </span>
    
    </div>
</div>

                
            </div>
        </section>
        
        


<script src="https://radish.cloud/js/bundle.f6c977229f84ae8df89c8647befcf3a170b8157f180a3f0afa4620b19a336994.js" integrity=""></script>








        
        
        
        
    </body>
</html>
