[{"categories":null,"content":"该项目为博主毕业设计项目，项目已开源 代码开源于：点击查看代码 该系统设计了一个面向 IT 领域的线上招聘网站，目标客户为企业所定义的校招生群体。系统使用业界成熟的分布式微服务架构，将庞大臃肿的单实例项目以能为模块进行拆分，拆分后模块耦合度低，复用性好，对单个模块可以灵活的进行拓展。架构还支持了服务治理，持续集成等技术，提高了系统的稳定性。 系统包括了常见的岗位管理，简历管理，职位投递等功能，还提供了模拟笔试，供应聘者学习的专栏模块，为求职者提高招聘备考效率，为求职者和企业提供双向的招聘解决方案 ","date":"0001-01-01","objectID":"/projects/demoproject/:0:0","tags":null,"title":"在线招聘系统","uri":"/projects/demoproject/"},{"categories":null,"content":"本文用于演示本站的对hugo写作功能的拓展以及实现 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:0:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"Mermaid 图 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:1:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"地图 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:2:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"Echarts ","date":"2021-06-05","objectID":"/posts/markdown-extend/:3:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"youtube 视频 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:4:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"哔哩哔哩视频 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:5:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"网易云音乐 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:6:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"单曲： ","date":"2021-06-05","objectID":"/posts/markdown-extend/:6:1","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"歌单： ","date":"2021-06-05","objectID":"/posts/markdown-extend/:6:2","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"Latex 行内样式：$x=2$ 代码块： $$ f(x)=\\int_{-\\infty}^\\infty\\widehat f\\xi,e^{2\\pi i\\xi x},d\\xi $$ ","date":"2021-06-05","objectID":"/posts/markdown-extend/:7:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"打字段落 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:8:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"参考 HEXO博客引用B站视频并自动适配 [拓展hugo的markdown_流程图mermaid Hugo博客LaTeX渲染) ","date":"2021-06-05","objectID":"/posts/markdown-extend/:9:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":["日志"],"content":"2018年的夏天，我坚持了仅仅两个月的博客，因为服务器到期关停了。当初的我还设定了一天一篇博客的“伟大”目标。然而直到博客关停的时候，仓库里还留着10多篇没有完结的草稿。在过去的两年时间里，我时常想把这个博客重新办起来，最终也因为各种原因一直也没有付诸于实践。 最近我有了一点宽裕的时间，为了督促自己学习，我决定复活我的博客。 幸运的是，虽然博客关停了，但是之前的文章和草稿还存在Github的仓库中。 为了更快的让博客上线，我决定使用Hugo来构建博客，可以很好的兼容之前用hexo搭建的博客锁写的文章。由于Hugo是生成的静态站点文件，所以我选择了Github Pages进行部署，这样可以大幅度减少维护服务器的时间，也方便进行自动化部署。但是由于某些原因，Github在大陆地区的大部分位置都访问缓慢，用我宿舍所使用的电信宽带，甚至直接无法访问。为改善这一问题，我使用了cloudflare和百度云加速对站点进行加速。 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:0:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"安装Hugo Hugo是一个静态网站生成框架，其官方网站号称是 “The world’s fastest framework for building websites” Hugo是使用Go语言实现的,相比使用javascript的Hexo，生成网站的速度确实要快很多，一次执行只需要几百毫秒。Hugo生成的网站是纯静态的，无需任何后端，部署和二次开发都很简单。使用Hugo写博客的工作流程很简单：首先使用markdown进行写作，在本地使用Hugo生成静态的网页，然后上传到任何可以访问的web服务器上就完成了，所以现在开始第一步：在本地安装Hugo。 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:1:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"使用二进制包进行安装 根据官方提供的快速指南，最直接的安装方式，就是下载二进制包，在Hugo的Github主页中，可以下载到各种平台(Windows,Linux,Mac )的二进制包，只要解压并在操作系统的环境变量中添加进去，就可以直接使用，使用hugo version指令可以查看hugo的安装情况 PS C:\\Users\\19796\u003e hugo version hugo v0.83.1-5AFE0A57+extended windows/amd64 BuildDate=2021-05-02T14:38:05Z VendorInfo=gohugoio ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:1:1","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"使用包管理进行安装 不过显然，使用包管理工具才是更加优雅便捷的安装方式，下面提供三种系统的安装方式 Mac Mac的用户直接使用Homebrew或者MacPorts就可以快速进行安装： brew install Hugo # 或者 port install Hugo Linux Linux用户也可以直接使用Homebrew进行安装，另外部分发行版，如Ubuntu中的软件源，提供hugo 的包，但是版本较老，不推荐使用，并且由于大多数现代主题使用了scss等技术，可能需要安装hugo-extend版本，镜像源中亦没有提供，所以推荐Linux用户使用二进制包或者Homebrew进行安装。 Windows 笔者使用的系统是Windows10，在Windows上也有一些流行的包管理工具中提供了hugo的安装，在这里我们推荐使用scoop进行安装 scoop install hugo # 或者安装hugo-extend scoop install hugo-extend 也可以使用Chocolatey进行安装 choco install hugo -confirm # or choco install hugo-extend -confirm 最近windows 中自带的包管理winget 终于转正，迎来了1.0版本，不过首批提供的1400个软件中并没有hugo，还是挺遗憾的。 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:1:2","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"使用源代码进行安装 使用源代码构建需要Git和 Go (版本不低于 Go 1.11)，，然后执行如下脚本就可以进行安装： mkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended 如果不需要Sass/SCSS等功能，可以去除–tags extende语句 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:1:3","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"新建一个站点 安装完成后，我们就可以新建第一个站点，首先进入你预先设定存放站点文件的目录，执行指令: hugo new site [your site name] 执行完成后，hugo会新建一个和站点同名的文件夹。进入目录,，文件结构如下： ├─archetypes ├─content ├─data ├─layouts ├─static └─themes 其中content是存放我们写作的文件的地方，static是存放站点相关静态文件的地方，例如图片，样式表等，themes是存放主题的地方，任何一个hugo站点，没有主题是无法完成构建，也就是无法看到效果的，所以我们首先需要安装一个主题。 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:1:4","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"安装Introdution主题 进入Hugo Themes (gohugo.io)可以查看所有的Hugo主题，选择一个即可。大部分的主题都实现了开箱即用，并且有着完善的教程，经过挑选，我选中了Hugo Theme Introduction )这一款主题，引用主题主页的介绍，该主题有如下优点： 多语言支持，官方支持英语，法语，德语，中文等多种语言 使用Markdown自定义页面 有一个展示项目的模块，还有博客功能 页面有着平滑的加载和跳转动画（确实是一个比较好的优点，很多主题需要自己添加插件） 通过config.toml直接定制功能 贯穿始终的Markdown风格，包括文章标题 支持代码高亮（代码高亮效果一言难尽） 其中的项目展示功能，优秀的动画系统让，我选择了这个主题，另外该主题还自动适配了黑暗模式，体验很好 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:2:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"准备 安装本主题需要hugo-extend版本，另外需要在系统上全局安装一些npm包用于编译scss npm i -g postcss postcss-cli autoprefixer 📌安装完成后，如果执行hugo server运行正常，但是执行构建报如下错误： Error: Error building site: POSTCSS: failed to transform \"css/main.css\" (text/css): resource \"sass/sass/style...\" not found in file cache 可以参考：CSS build issues · Issue #210 · victoriadrake/hugo-theme-introduction ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:2:1","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"安装主题 安装完成后可以进入你站点的根目录，安装主题 git clone https://github.com/victoriadrake/hugo-theme-introduction.git themes/introduction clone完成后，主题安装在站点目录的themes/introduction里，hugo的主题中均包含一个示例站点，在站点目录执行如下指令查看示例站点： cd themes/introduction/exampleSite/ hugo serve --themesDir ../.. 展示站点效果可以查看本站首页 配置 修改站点配置可以使用主题所设置的自定义功能，也可以设置站点的信息等，站点配置文件位于config.toml文件中 点击查看本站完整的站点配置，关键位置均有注释 publishdir = \"docs\" baseURL = \"https://radish.cloud/\" # Your domain name. Must end with \"/\" theme = \"introduction\" DefaultContentLanguage = \"cn\" # Default language for multilingual sites # disqusshortname = \"\" # https://gohugo.io/content-management/comments # googleAnalytics = \"\" # https://gohugo.io/templates/internal/#google-analytics [params] themeStyle = \"auto\" # Choose \"light\" or \"dark\" or \"auto\" favicon = \"/img/fav.ico\" # Path to favicon file showRSSButton = true # Show rss button in navigation fadeIn = true # Turn on/off the fade-in effect fadeInIndex = false # Turn on/off the fade-in effect on the index page even if fade-in was otherwise turned off dateFormat = \"Jan 2, 2006\" email = \"mx@radish.cloud\" # E-mail address for contact section customCSS = [\"foo.css\"] # Include custom css files placed under assets/ # customJS = [\"foo.js\"] # Include custom JavaScript files placed under assets/ # plausible = true # Use Plausible analytics (requires an account at Plausible.io) toc = true # autoCollapseToc = true [params.utteranc] enable = true repo = \"Lairdkin/blog\" # 存储评论的Repo，格式为 owner/repo issueTerm = \"pathname\" # 表示你选择以那种方式让github issue的评论和你的文章关联可以选择默认的pathname。 theme = \"preferred-color-scheme\" # Configure the home page [params.home] introHeight = \"fullheight\" # Input either \"medium\" or \"large\" or \"fullheight\" showLatest = true # Show latest blog post summary showAllPosts = false # Set true to list all posts on home page, or set false to link to separate blog list page allPostsArchiveFormat = true # show all posts in an archive format numberOfProjectsToShow = 3 # Maximum number of projects to show on home page. Unset or comment out to show all projects localTime = true # Show your current local time in contact section timeZone = \"Asia/Shanghai\" # Your timezone as in the TZ* column of this list: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones timeFormat = \"zh-CN\" # Language specific format to use [params.projects] useTwoColumns = false # Use a layout with two columns instead of three # Share buttons on blog post pages [params.share] twitter = true facebook = true pinterest = true # Social icons appear in introduction and contact section. Add as many more as you like. # Icon pack \"fab\" includes social network icons, see: https://fontawesome.com/icons?d=gallery\u0026s=brands\u0026m=free # Icon pack \"fas\" includes solid style icons, see: https://fontawesome.com/icons?d=gallery\u0026s=solid\u0026m=free [[params.social]] url = \"https://twitter.com/menxin74\" icon = \"twitter\" # icon name without the 'fa-' icon_pack = \"fab\" [[params.social]] url = \"https://t.me/radishcloud\" icon = \"telegram\" # icon name without the 'fa-' icon_pack = \"fab\" [[params.social]] url = \"https://github.com/RadishKin\" icon = \"github\" # icon name without the 'fa-' icon_pack = \"fab\" [[params.social]] url = \"https://weibo.com/1910759497\" # For a direct email link, use \"mailto:test@example.org\". icon = \"weibo\" # icon name without the 'fa-' icon_pack = \"fab\" [[params.social]] url = \"https://discord.gg/z3nEreaJvk\" icon = \"discord\" # icon name without the 'fa-' icon_pack = \"fab\" html_attributes = \"rel=\\\"me\\\"\" # Add rel attribute for Mastodon profile link verification [taxonomies] tag = \"tags\" series = \"series\" [markup] defaultMarkdownHandler = \"goldmark\" [markup.goldmark] [markup.goldmark.renderer] unsafe = true [markup.highlight] codeFences = true guessSyntax = true hl_Lines = \"\" lineNoStart = 1 lineNos = true lineNumbersInTable = false noClasses = true # For styles, see https://xyproto.github.io/splash/docs/longer/all.html style = \"monokai\" tabWidth = 4 [languages] [languages.en] languageName = \"English\" languageCode = \"e","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:2:2","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"新建站点文件 主题的首页，是对应语言文件夹中的/home目录,默认的主页需要新建about.md,contact.md,index.md三个文件，分别对应首页的about，contact两个模块，以及最上面的标题部分。 index.md的tittle属性，为对应站点的名称，正文部分为站点的附标题，示例如下： --- title: \"无名博客\" date: 2021-05-28T01:53:59+08:00 --- Anonymous blog \u003c/br\u003e 匿名\u003cruby\u003e\u003crb\u003eブログ\u003c/rb\u003e\u003crt\u003eblog\u003c/rt\u003e\u003crp\u003e(blog)\u003c/rp\u003e\u003c/ruby\u003e contact和index的title属性，是对应板块在导航栏的名称， ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:2:3","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"编译站点 修改完成配置后就可以可以编译静态站点了，首先在配置文件中添加publishdi = \"docs\"配置，编译生成的文件会默认放在站点根目录的/docs目录中，该目录是github pages的默认目录，方便后面部署。 保存配置文件后执行 hugo 即可生成站点文件 其中docs/就是hugo生成的静态站点文件 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:2:4","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"部署github pages和cloudflare ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:3:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"为博客添加评论 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:4:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"私有部署评论服务 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:5:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"主题功能修改 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:6:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"TODO 添加博客邮件订阅功能，参见 博客利器：使用 mailchimp 将 RSS 转为邮件订阅 - 少数派 (sspai.com) ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:7:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":null,"content":"萝卜云服务 sci-hub服务：https://sci.radish.cloud 🎯该服务暂不可用 rsshub服务：https://rss.radish.cloud 部分接口限速 github加速服务：https://github.radish.cloud 网页代理服务（jsproxy）：https://jsproxy.radish.cloud utterances评论：https://https://utterances.radish.cloud/ （本站使用的评论服务 如需使用可以联系博主开通github app 安装权限） ","date":"2021-05-29","objectID":"/links/:0:1","tags":null,"title":"友情链接","uri":"/links/"},{"categories":null,"content":"Telegram频道 豆瓣购物优惠推送频道：https://t.me/Douban_what2buy 明日方舟咨讯频道：https://t.me/Akunitsu ","date":"2021-05-29","objectID":"/links/:0:2","tags":null,"title":"友情链接","uri":"/links/"},{"categories":null,"content":"Anonymous blog 匿名ブログblog(blog) ","date":"2021-05-28","objectID":"/home/:0:0","tags":null,"title":"无名博客","uri":"/home/"},{"categories":["笔记"],"content":"转载自 ： {% blockquote 哎呦AU的博客 https://www.cnblogs.com/aurum324/p/8167996.html POJO,JAVABEAN,Entity区别 %} {% endblockquote %} ","date":"2018-05-28","objectID":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/:0:0","tags":["java","JavaEE"],"title":"[转载]POJO,JAVABEAN,Entity区别","uri":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/"},{"categories":["笔记"],"content":"1、javaBean javaBean是一种Java语言写成的可重用组件。为写成JavaBean，类必须是具体和公共的，并且具有无参数的构造器。JavaBean通过提供符合一致性设计模式的公共方法将内部域暴露成员属性。更多的是一种规范，即包含一组set和get方法的java对象。javaBean可以使应用程序更加面向对象，可以把数据封装起来，把应用的业务逻辑和显示逻辑分离开，降低了开发的复杂程度和维护成本。 ","date":"2018-05-28","objectID":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/:0:1","tags":["java","JavaEE"],"title":"[转载]POJO,JAVABEAN,Entity区别","uri":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/"},{"categories":["笔记"],"content":"2、ejb 即EnterpriseBean，也就是Enterprise JavaBean（EJB）。 ejb是JavaEE的一部分，定义了一个用于开发基于组件的企业多重应用程序标准。它被称为Java企业Bean，是java的核心代码，分别是回话Bean（Session Bean）、实体Bean（Entity Bean）、和消息驱动Bean（MessageDriven Bean）。 ","date":"2018-05-28","objectID":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/:0:2","tags":["java","JavaEE"],"title":"[转载]POJO,JAVABEAN,Entity区别","uri":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/"},{"categories":["笔记"],"content":"3、pojo （Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。 其中有一些属性及其getter、setter方法的类，没有业务逻辑，有时可以作为VO（value-object）或DTO（Data Transfer Object）来使用。不允许有业务方法，也不能携带connection之类的方法。 与javaBean相比，javaBean则复杂很多，JavaBean是可复用的组件，对JavaBean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于JavaBean是被容器创建的，所以JavaBean应具有一个无参的构造器。另外，通常JavaBean还要实现Serializable接口用于实现Bean的持久性。一般在web应用程序中建立一个数据库的映射对象时，我们只能称他为POJO。用来强调它是一个普通的对象，而不是一个特殊的对象，其主要用来指代哪些没有遵从特定的java对象模型、约定或框架（如EJB）的java对象。理想的将，一个POJO是一个不受任何限制的java对象 ","date":"2018-05-28","objectID":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/:0:3","tags":["java","JavaEE"],"title":"[转载]POJO,JAVABEAN,Entity区别","uri":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/"},{"categories":["笔记"],"content":"4、entity 实体bean，一般是用于ORM对象关系映射，一个实体映射成一张表，一般无业务逻辑代码。 负责将数据库中的表记录映射为内存中的Entity对象，事实上，创建一个EntityBean对象相当于创建一条记录，删除一个EntityBean对象会同时从数据库中删除对应记录，修改一个Entity Bean时，容器会自动将Entity Bean的状态和数据库同步。 ","date":"2018-05-28","objectID":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/:0:4","tags":["java","JavaEE"],"title":"[转载]POJO,JAVABEAN,Entity区别","uri":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/"},{"categories":["笔记"],"content":"5 、DTO 数据传输对象（Data Transfer Object）。是一种设计模式之间传输数据的软件应用系统。数据传输目标往往是数据访问对象从数据库中检索数据 ","date":"2018-05-28","objectID":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/:0:5","tags":["java","JavaEE"],"title":"[转载]POJO,JAVABEAN,Entity区别","uri":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/"},{"categories":["笔记"],"content":"转载自 ： {% blockquote 落落无伤的博客 https://www.cnblogs.com/qianqian528/p/8032098.html 常用数据库 JDBC URL 格式 %} {% endblockquote %} ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:0:0","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"一 常用数据库 JDBC URL 格式 ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:1:0","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"1 sqLite 驱动程序包名：sqlitejdbc-v056.jar 驱动程序类名: org.sqlite.JDBC JDBC URL: jdbc:sqlite:c:\\*.db 默认端口 无 ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:1:1","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"2 Microsoft SQL Server Microsoft SQL Server JDBC Driver 驱动程序包名：msbase.jar mssqlserver.jar msutil.jar 驱动程序类名: com.microsoft.jdbc.sqlserver.SQLServerDriver JDBC URL: jdbc:microsoft:sqlserver://\u003cserver_name\u003e:\u003cport\u003e 默认端口1433，如果服务器使用默认端口则port可以省略 ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:1:2","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"3 Oracle Oracle Thin JDBC Driver 驱动程序包名：ojdbc14.jar 驱动程序类名: oracle.jdbc.driver.OracleDriver JDBC URL: jdbc:oracle:thin:@//\u003chost\u003e:\u003cport\u003e/ServiceName 或 jdbc:oracle:thin:@\u003chost\u003e:\u003cport\u003e:\u003cSID\u003e ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:1:3","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"4 IBM DB2 IBM DB2 Universal Driver Type 4 驱动程序包名：db2jcc.jar db2jcc_license_cu.jar 驱动程序类名: com.ibm.db2.jcc.DB2Driver JDBC URL: jdbc:db2://\u003chost\u003e[:\u003cport\u003e]/\u003cdatabase_name\u003e ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:1:4","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"5 MySQL MySQL Connector/J Driver 驱动程序包名：mysql-connector-java-x.x.xx-bin.jar 驱动程序类名: com.mysql.jdbc.Driver JDBC URL: jdbc:mysql://\u003chost\u003e:\u003cport\u003e/\u003cdatabase_name\u003e 默认端口3306，如果服务器使用默认端口则port可以省略 MySQL Connector/J Driver 允许在URL中添加额外的连接属性 jdbc:mysql://\u003chost\u003e:\u003cport\u003e/\u003cdatabase_name\u003e?property1=value1\u0026property2=value2 注意： 需要操作记录为了避免乱码应该加上属性 useUnicode=true\u0026characterEncoding=utf8 ，比如 jdbc:mysql://192.168.177.129:3306/report?useUnicode=true\u0026characterEncoding=utf8 ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:1:5","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"二 Hibernate 中数据库的方言 ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:2:0","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"1 Oracle 方言 org.hibernate.dialect.OracleDialect ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:2:1","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"2 MySQL方言 org.hibernate.dialect.MySQLDialect 3 SQLServer方言 org.hibernate.dialect.SQLServerDialect ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:2:2","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"如今，如果你作为一个开发者而不知道容器化技术，那你可能要反思一下自己了，作为计算机领域发展最快最热门的技术之一，容器成为了现代互联网服务架构的基石。 2013年DotCloud发布了容器服务Docker，并在2015年发布了其第一个正式版本，同年国内的Daocloud和灵雀云等公司开始提供基于docker的云服务业务，正是在此机会下我有幸接触了当时还非常先进的容器化技术（其实我当时对容器化还没有任何概念）。Docker在当时给我留下了最大的印象就是启动快，部署非常快，并且我当时参照daocloud官方提供的教程构建了一些镜像，不过当时的我，只是把Docker作为了一种新奇好玩的玩具，而没有深入的了解和使用。 时间转到今天，随着微服务的兴起，容器化技术已经成为了微服务架构中的重要基石，docker对我来说不再是一个玩具，而是重要的开发部署工具，从今天起，我将重新开始学习docker,并用一系列文章来记录我学习过程。 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:0:0","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Docker 概述 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:1:0","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"什么是Docker 虽然Docker及其背后代表的容器化技术已经非常热门了，但是容器化并不是什么新技术，于1979年出现的Chroot Jailb被认为是Dcoker技术的起源，也就是现代Linux系统中的chroot环境，下面列出的一些都是早期的容器服务： Chroot Jail FreeBSD Jails Linux VServer Solaris Containers OpenVZ Process Containers LXC Warden LMCTFY Docker RKT 正如我们所看到的，docker 并不是第一个容器化技术，但它的确是最知名的一个。Docker 诞生于 2013 年，并获得了快速的发展。 所以到底什么是Docker呢？ 我们看看书本上的说法： Docker使用Google公司推出的Go语言进行开发实现，基于 Linux内核的cgroup，namespace，以及AUFS类的Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于LXC，从0.7以后开始去除LXC，转而使用自行开发的libcontainer，从1.11开始，则进一步演进为使用runC和containerd。 Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 实际上docker本质上就是一种虚拟化技术，与传统的虚拟化技术不同的是，他没有在虚拟化环境中虚拟出一个完整的操作系统内核，而是将虚拟化环境中的进程放在物理机内核中执行,这就是docker容器化的核心。这种方式使docker具有了很多传统虚拟化方式没有的优势。 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:1:1","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"为什么选择docker 更高效的利用系统资源 由前文我们知道，dcoker容器内的程序本质上就是宿主机上运行的进程，这样就极大减小了性能的损耗，由于不需要模拟内核和周边硬件，也节省了这部分的性能损耗 更快的启动时间 docker容器本质就是一个个宿主机内核程序，所以启动较快 运行环境一致性 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性 持续交付和部署 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署(Continuous Delivery/Deployment) 系统进行自动部署。 更轻松的维护和拓展 Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:1:2","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Docekr的镜像与容器 首先我们了解三个Docker的基本概念 镜像（Image） 容器（Container） 仓库（Repository） 这三个概念组成了Docker的完整生命周期，我们将在下面的过程中详细介绍 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:2:0","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"环境 如今，Docker可以运行在所有的主流操作系统上，包括Linux，Windows，MacOSX，因为我平时喜欢使用Linux，本文将在Linux上部署和使用，我将使用我的笔记本电脑和一台Daocloud胶囊主机来完成本文的内容 本地环境：Manjaro Linux18.0+Docker18.09.0-ce, 远程主机环境：Ubuntu14.04+(因为写作到这的时候断网了就放弃远程环境了) 在Manjaro安装Docker非常简单，在终端输入： sudo Pacman -S docker-ce 即可安装，并无需额外配置 启动Docker服务 systemctl start docker 检查Docker版本 $ docker --version Docker version 18.09.0-ce, build 4d60db472b Docker就安装好了 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:2:1","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"镜像 首先我们将了解Docker最核心的概念之一：镜像。镜像是Docker特殊的文件存储形式，其中储存了Linux运行时的用户空间，根据Linux的设计，Linux分为内核和用户空间，宿主机为Docker容器运行提供了内核支持，而Linux镜像为Docker运行提供了用户空间的支持。除了Linux的用户空间外，Docker镜像还储存了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等），Docker镜像不包含任何动态数据，构建完成后不会被改变。 由于docker使用了UnionFS技术，所以Docker实现了分层储存的特性，镜像并非是一个完整的“镜像”文件，而是一种抽象概念，在存储中，Docker镜像根据构建顺序依次完成储存，不同的镜像可以共享其中的中间层，大大减小了Docker镜像的体积。 获取镜像 Docker运行前需要对应的镜像，所以我们可以从镜像仓库拉取镜像，Docker默认的镜像仓库是DockerHub，其中内置了大量高质量的Dokcer基础镜像，我们也可以将自己的镜像发布至DockerHub 前文我们提到了仓库（Repository）的概念，仓库是一个集中存储和分发镜像的服务，一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。我们可以部署只自己仓库，也可以使用公共的仓库服务。 获取镜像使用docker pull命令： docker pull [选项] [Docker Registry地址]\u003c仓库名\u003e:\u003c标签\u003e 如没有仓库地址名，将使用默认的仓库。 例如： $ sudo docker pull node:latest latest: Pulling from library/node 54f7e8ac135a: Already exists d6341e30912f: Already exists 087a57faf949: Already exists 5d71636fb824: Pull complete 0c1db9598990: Pull complete 89669bc2deb2: Pull complete 647616206038: Pull complete 64f67f03205b: Pull complete Digest: sha256:fed3f48ec9e97a57c17977ff120c3e7bf7d2d4e930ef650bba3f2ada5ac4a33a Status: Downloaded newer image for node:latest 这个命令将在Docker的中央仓库下载一个最新版本的Nodejs镜像 列出镜像 我们可以使用docker images列出所有本地的镜像 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker-test 0.0.1 ce25b22437c5 9 days ago 443MB node latest 37f455de4837 9 days ago 894MB tomcat latest 48dd385504b1 9 days ago 475MB ubuntu latest 93fd78260bd1 3 weeks ago 86.2MB fabric8/java-jboss-openjdk8-jdk 1.2.3 7a2a8001c977 23 months ago 422MB 列表包含了仓库名、标签、镜像 ID、创建时间以及所占用的空间。 docker分层构建的方式产生了大量的中间层镜像，docker默认只显示最外层的镜像，我们可以通过以下命令查看 $ docker images -a 此外docker images还可以通过一些条件来查看镜像： # 查看特定仓库名的镜像 $ sudo docker images ubuntu REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 93fd78260bd1 3 weeks ago 86.2MB # 使用过滤器查看镜像 # 从某个镜像开始的所有镜像 sudo docker images -f since=ubuntu # 查看特点标签的镜像 docker images -f label=com.example.version=0.1 # 使用Go语言模板制定输出格式 $ docker images --format \"table {{.ID}}\\t{{.Repository}}\\t{{.Tag }}\" 删除镜像 当我们不需要某个镜像的时候，我们可以选择删除镜像，使用docker rmi命令即可删除镜像 例如： $ sudo docker rmi tomcat:latest 构建镜像 使用DockerFile构建镜像将在下一篇文章中详细展开 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:2:2","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"容器 如果你熟悉面向对象的开发的话，你可能更容易理解镜像与容器之间的关系。镜像就是面向对象中的类，而容器就是实例，容器就是实例化的镜像，容器是动态的。如前文所述，容器的实质是宿主机中的进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间,容器内的进程是隔离与宿主机环境的。 运行 当我们有了镜像之后，我们就可以运行我们的镜像并建立新的容器（实例）,docker使用docker run 命令来运行容器 $ sudo docker run -it --rm ubuntu /bin/bash root@d332f4d5aecb:/# cat /etc/os-release NAME=\"Ubuntu\" VERSION=\"18.04.1 LTS (Bionic Beaver)\" ID=ubuntu ID_LIKE=debian PRETTY_NAME=\"Ubuntu 18.04.1 LTS\" VERSION_ID=\"18.04\" HOME_URL=\"https://www.ubuntu.com/\" SUPPORT_URL=\"https://help.ubuntu.com/\" BUG_REPORT_URL=\"https://bugs.launchpad.net/ubuntu/\" PRIVACY_POLICY_URL=\"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\" VERSION_CODENAME=bionic UBUNTU_CODENAME=bionic root@d332f4d5aecb:/# exit exit –it ：这是两个参数，一个是 -i ：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终获取镜像终端。 –rm ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。 ubuntu:14.04 ：这是指用 ubuntu:14.04 镜像为基础来启动容器。 /bin/bash ：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash 。 当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从公有仓库下载 启动 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 我们可以使用-d参数使容器在后台运行，例如： $ sudo docker run -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a 使用docker ps 可以查看docker容器运行状态 $ sudo docker ps 希望获取docker日志信息 docker logs 77b2dc01 终止容器 当我们需要终止容器时可以使用docker stop 命令,当容器z中的应用终止时，容器也会自动终止，可以使用docker ps -a 查看中止的容器，终止的容器可以用docker start来重新启动,同理，docker restart 将会将容器重启 删除容器 可以使用 docker rm 来删除一个处于终止状态的容器。 例如 $sudo docker rm trusting_newton trusting_newton 如果要删除一个运行中的容器，可以添加-f参数。Docker 会发送 SIGKILL 信号给容器。 使用如下命令可以终结全部处于终止状态的容器 docker rm $(docker ps -a -q) 其他操作 导出容器 如果要导出本地某个容器，可以使用 docker export 命令。 $ sudo docker export 3f6\u003ejava.tar 导入容器 导出的本地镜像可以用docker import命令来导入 cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0 下一篇文章，我们讲讲解docker构建镜像的常见方式 参考 杨保华,戴王剑，曹亚伦-Docker技术入门与实战第二版 alonghub-Docker的发展历程 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:2:3","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"最近记性实在是下降的厉害，搞的东西天天忘，所以把咕了好几年的博客又捡起来了，这次选用了Hexo作为博客的引擎，支持markdown，轻量，部署简单，不过安装中还是踩了一些坑，简单的记录下（其实就是博客太空水一篇2333 \rfetch(\"https://demo.radishkin.workers.dev/api/set?url=\"+window.btoa(location.href)).then(res={\rconsole.log(res)\r})\r\r","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"环境 服务器：阿里云学生机 轻量级应用服务器 服务器系统：Ubuntu16.04 阿里云一直不提供1804的镜像，但是不推荐手动升级，容易挂 本地系统：Manjaro 18.0 Illyria ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:0","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"部署 Hexo生成的是纯静态页面，所以部署只需将hexo生成的public目录放置在 nginx 站点目录下就可以 ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:0","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"Hexo 安装 安装Hexo 前确保系统有以下软件： Node.js Git 因为Ubuntu源中提供的nodejs版本非常老，所以我们使用官网提供的一个安装方式来安装nodejs # Using Ubuntu curl -sL https://deb.nodesource.com/setup_11.x | sudo -E bash - sudo apt-get install -y nodejs # Using Debian, as root curl -sL https://deb.nodesource.com/setup_11.x | bash - apt-get install -y nodejs 这个脚本会自动识别系统版本并添加ppa源 然后 # 安装git sudo apt install git 因为我们是在服务器端调用hexo生成静态页面，所以本地只需要安装git就可以 # manjaro 安装git sudo pacman -S git # 也可以在本地安装nodejs，方便调试 sudo pacman -S nodejs 然后安装hexo npm install -g hexo-cli 测试一下 hexo -v 输出 hexo-cli: 1.1.0 os: Linux 4.19.1-1-MANJARO linux x64 http_parser: 2.8.1 node: 11.1.0 v8: 7.0.276.32-node.7 uv: 1.23.2 zlib: 1.2.11 ares: 1.15.0 modules: 67 nghttp2: 1.34.0 napi: 3 openssl: 1.1.1 icu: 63.1 unicode: 11.0 cldr: 34.0 tz: 2018e Hexo 安装完毕 ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:1","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"Hexo新建站点和基本配置 选择一个存放站点文件的目录，执行 hexo init “站点名” hexo会在当前目录下新建一个站点文件夹，cd进站点文件夹，执行 npm install 执行完成后，生成目录如下 $ tree blog blog ├── _config.yml ├── db.json ├── node_modules ├── package.json ├── package-lock.json ├── scaffolds ├── source └── themes 其中_config.yml是整个站点的配置文件，source是存放文章来源的md文件的，package.json存放了站点的依赖，theme是主题文件 在站点文件夹内，使用 hexo g 生成静态文件，静态文件存放在该目录的public/下 然后编辑_config.yml # 站点基本信息title:#站点名称subtitle:#子标题description:keywords:author:language:zh-cn#语言设置为简体中文timezone:# 站点链接配置url:http://ljmx.toproot:/permalink::year/:month/:title.htmlpermalink_defaults:# 一些默认文件的配置source_dir:sourcepublic_dir:publictag_dir:tagsarchive_dir:archivescategory_dir:categoriescode_dir:downloads/codei18n_dir::langskip_render:# 使用hexo new 时写作模板# 因为平时都是直接新建md文件，所以这里一般都用不上QAQ# new_post_name::title.md# File name of new postsdefault_layout:posttitlecase:false# Transform title into titlecaseexternal_link:true# Open external links in new tabfilename_case:0render_drafts:falsepost_asset_folder:falserelative_link:falsefuture:truehighlight:enable:trueline_number:trueauto_detect:falsetab_replace:# 主页设定，这个一般根据主题来修改index_generator:path:''per_page:10order_by:-date# 标签default_category:uncategorizedcategory_map:tag_map:#日期格式date_format:YYYY-MM-DDtime_format:HH:mm:ss# 分页per_page:10pagination_dir:page# 拓展，主题和插件## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme:anatole# Deployment## Docs: https://hexo.io/docs/deployment.html# 自动部署配置，没用过2333deploy:type: 然后可以选择一个自己喜欢的主题，放到/theme 文件夹里，在配置文件theme行写上主题名称，生成文件即可更换主题 我们使用的主题依赖 hexo-render-pug插件，所以启用前需要执行 npm install hexo-render-pug --save安装，才能正常渲染 ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:2","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"Nginx 配置 ubuntu1604 安装nginx sudo apt install nginx 查看服务状态 service nginx status Active状态显示 active证明配置正常 编辑/etc/nginx/nginx.conf #修改第一行，变更nginx执行权限，其实不推荐这样做，应该修改文件的访问权限，但是我懒233 user root #增加一下一行到文件中 include /etc/nginx/conf.d/*.conf; 然后在/etc/nginx/conf.d目录中新建一个站点名.conf的文件，编辑这个文件 server { listen 4000; # 监听端口 server_name ljmx.top; # 站点域名 root /var/www/public; # 站点根目录,指向自己站点的public文件夹 index index.html index.htm index.php; # 默认导航页 } 重启nginx service nginx restart ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:3","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"webhook实现自动部署 现在博客部署好了，但是我每次写完文章，push到github，然后登录服务器，pull下来，执行生成语句，这样比较繁琐，所以我们的webhook就登场了 webhook是git上的一个服务，他提供了一种能力，当仓库发生变动时，webhook会自动post一段信息到预先设定的地址。通过这种方式，我们可以实现自动化生成和部署博客 在github项目主页中，点击setting\u003ewebhooks，然后ADD一个新的webhook，Payload URL填写服务器ip+端口号+请求路径，请求类型选json，sceret随便生成，但是要记住。 在hexo站点根目录下新建一个叫webhook.js文件， 填入以下内容: var http = require('http') var createHandler = require('github-webhook-handler') var handler = createHandler({ path: '/webhooks_push', secret: '' }) // 上面的 secret 保持和 GitHub 后台设置的一致 function run_cmd(cmd, args, callback) { var spawn = require('child_process').spawn; var child = spawn(cmd, args); var resp = \"\"; child.stdout.on('data', function(buffer) { resp += buffer.toString(); }); child.stdout.on('end', function() { callback (resp) }); } handler.on('error', function (err) { console.error('Error:', err.message) }) handler.on('push', function (event) { console.log('Received a push event for %s to %s', event.payload.repository.name, event.payload.ref); run_cmd('sh', ['./deploy.sh'], function(text){ console.log(text) }); }) try { http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404 res.end('no such location') }) }).listen(6000) //可以在这修改监听端口号 }catch(err){ console.error('Error:', err.message) } 在目录下新建一个deploy.sh的文件，填入以下内容 #填入markdown文件所在位置 cd /root/website/myblog/source git reset --hard git pull origin master hexo generate 然后安装依赖： npm install github-webhook-handler --save 运行 node webhook.js 可以使用pm2，或者nohup等方式守护进程 这样当提交pull request的时候，服务器就会自动生成静态文件并部署了 ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:4","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"其他 因为时间匆忙（其实就是懒，所以很多东西还没有完善，留给下篇博文吧 待完成 修改博客模板 全站ssl 访问统计 资源文件夹 多用户 ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:0","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"Springboot是由spring开发团队Pivotal推出的全新框架，他设计目的简化繁琐的Spring配置,专注于应用的开发。SpringBoot采用了\"约定优先于配置（COC，Convnetion Over Configuration）“的设计思想，通过为企业开发应用环境设计出了很多自动配置的依赖模块,这些模块几乎不需要配置，开箱即用，极大的简化了开发周期和代码量。 ","date":"2018-05-28","objectID":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:0:0","tags":["java","Springboot"],"title":"Springboot快速上手","uri":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["笔记"],"content":"环境 本文开发环境以写作时的最新版本2.1.0.RELEASE为基准 JDK1.8及以上 Maven 3.2 Tomcat 8及以上 hibernate 5.2以上 使用最新版idea可以快速创建一个springboot项目并初始化一些模块，如果不使用idea，可以新建Maven项目并从官网下载并定制所需组件 ","date":"2018-05-28","objectID":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:0:1","tags":["java","Springboot"],"title":"Springboot快速上手","uri":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["笔记"],"content":"项目Maven依赖 我们使用Maven作为项目的的依赖管理，有关Maven的内容可以查看网上的其他相关信息，下面列出了项目所有使用的模块 继承Springboot的核心依赖 \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.1.0.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e jpa \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e \u003c/dependency\u003e web核心组件 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e mysql ,如果mysql-server版本是8.0需要指明connector版本8.0+ \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e lmbok，减少代码量 \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e Springboot 测试模块，默认使用junit \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e swagger \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e2.2.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e2.2.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2018-05-28","objectID":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:0:2","tags":["java","Springboot"],"title":"Springboot快速上手","uri":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["笔记"],"content":"工程目录结构 然后我们查看下项目生成的默认文件结构 $ tree . ├── mvnw ├── mvnw.cmd ├── pom.xml ├── src │ ├── main │ │ ├── java │ │ │ └── top/ljmx/springboot/demo/demo │ │ │ └── DemoApplication.java │ │ └── resources │ │ ├── application.properties │ │ ├── static │ │ └── templates │ └── test │ └── java │ └── top/ljmx/springboot/demo/demo │ └── DemoApplicationTests.java └── srpingboot-sdemo.iml 18 directories, 7 files src是项目的主文件夹，其中main是主要代码，test是测试代码，这是一个典型的Maven工程的文件结构，pom.xml是Maven的依赖文件。main先分为java和resources，java存放代码，resources存放静态资源，目录中的application.properties是工程的配置文件 Springboot遵循springMVC的分层结构结构，所以我们先在包top.ljmx.springboot.demo.demo下新建以下几个子包 controller 存放所有的控制器代码 model 存放所有的数据模型 repository 存放所有的数据操作 service 业务代码 其他可选包 config 存放配置代码，如swagger util 存放工具类 expection 统一异常处理 ","date":"2018-05-28","objectID":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:0:3","tags":["java","Springboot"],"title":"Springboot快速上手","uri":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["笔记"],"content":"一个简单的Springboot入门实例 本实例参照库米云微王华杰老师课程代码 本实例实现了一套登陆与注册接口，并使用slflog收集日志，并用swagger2提供文档和测试服务 编辑resources目录下的application.properties文件 #tomcat configserver.port = 8080server.tomcat.uri-encoding = utf-8#Mysqlspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver#配置mysql驱动spring.datasource.url = jdbc:mysql://localhost:3306/test?useUnicode=true\u0026characterEncoding=utf8\u0026serverTimezone=GMT%2B8#serverTimezone=GMT%2B8是解决运行中出现f服务器时区无法识别的异常的spring.datasource.username = rootspring.datasource.password = ***********#jpaspring.jpa.database = mysqlspring.jpa.show-sql = truespring.jpa.hibernate.ddl-auto = updatespring.jpa.hibernate.naming.physical-strategy = org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy#数据库方言mysqlspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect 然后在MySQL中新建一个名叫test的数据库 然后先新建一个用户实体类，在model包下新建一个User.java,写入以下内容 package top.ljmx.demo.model; import lombok.Data; import javax.persistence.Entity; import javax.persistence.*; @Entity //声明数据实体类 @Data //产生setter，getter方法 public class User { @Id //标识主键 @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer keyid; private String userName; private String phoneNumber; private String password; } 可以在该类添加@table注解可以指定自动生成的表的类名 然后基于JPA实现DAO层（数据操作层，就是repository包），新建一个UserRepositoty的类，代码如下 package top.ljmx.demo.repositoty; import org.springframework.data.jpa.repository.Query; import top.ljmx.demo.model.User; import org.springframework.stereotype.Repository; import org.springframework.data.jpa.repository.JpaRepository; @Repository public interface UserRepositoty extends JpaRepository\u003cUser,Integer\u003e{ @Query(\"select a from User a where a.phoneNumber=?1\") User getByPhoneNumber(String phoneNumber); } 需要解释的是，Spring Data JPA提供了很多持久层接口，例如Repository,CrudRepositoty,PagingAndSortingRepository 以及JpaRepository 接口。其中Repository为基类，JpaRepository继承自PagingAndSortingRepository接口，两个泛型参数分别代表Java POJO类以及主键数据类型。我们创建自己的数据库操作接口时，只需继承上述JPA提供的某个接口，即可自动继承相关数据操作方法，而不需要再次实现。例如CrudRepositoty提供了对增删改查操作的实现，PagingAndSortingRepository提供了分页查询方法的实现。另外JPA提供了一套命名规则例如readBy()等，这些方法也只需要用户申明而由JPA自动实现了。如果这仍不能满足业务需求，也可以自定义SQL查询语句，例如上述代码所示，采用@Query标签,我们之后将开设单独的一章讲解JPA 最后实现控制器类，在包 controller中新建UserController类 package top.ljmx.demo.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import top.ljmx.demo.model.User; import top.ljmx.demo.repositoty.UserRepositoty; //Spring组合注解,声明Rest接口 @RestController public class UserController { @Autowired //自动装配成员变量 private UserRepositoty userRepositoty; @ApiOperation(value = \"注册\") @RequestMapping(value = \"/user/register\",method = RequestMethod.GET) //地址映射，并指定请求方法 public Object register( @RequestParam(\"username\") String userName, @RequestParam(\"phonenumber\") String phoneNumber, @RequestParam(\"password\") String password){ //参数列表 User user = new User(); user.setUserName(userName); user.setPhoneNumber(phoneNumber); user.setPassword(password); try { userRepositoty.save(user); //实例化对象 }catch (Exception e){ return \"注册失败\"; } return \"注册成功\"; } @RequestMapping(value = \"/user/login\",method = RequestMethod.GET) public Object login(@RequestParam(\"phonenumber\") String phoneNumber, @RequestParam(\"password\") String password){ User user = userRepositoty.getByPhoneNumber(phoneNumber); if (user.getPassword().equals(password)){ return \"登录成功\"; }else { return \"登录失败\"; } } } 这个控制器实现了login和register两个接口,可以模拟简单的登录和注册功能 当我们配置好数据库信息时， 运行main函数，访问http://localhost:8080/user/register?username=mx\u0026phonenumber=1234546\u0026password=123会在数据库中新建一条数据,访问http://localhost:8080/user/login?phonenumber=123454\u0026password=123(数据表里存在的数据)会输出登录正常。 之后的文章会对这个简单的注册登录做更多改进 参考：https://blog.csdn.net/u013248535/article/details/55100979/ ","date":"2018-05-28","objectID":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:0:4","tags":["java","Springboot"],"title":"Springboot快速上手","uri":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["笔记"],"content":"想要深入了解JVM，就必须了解其实现机制。了解JVM实现的最好方法便是自己动手编译JDK。本文中，我将参照《深入理解Java虚拟机》中的教程，编译openjdk1.8 ","date":"2018-05-28","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/:0:0","tags":["java","jdk","jvm"],"title":"一次失败的jdk编译","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/"},{"categories":["笔记"],"content":"准备工作 ","date":"2018-05-28","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/:1:0","tags":["java","jdk","jvm"],"title":"一次失败的jdk编译","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/"},{"categories":["笔记"],"content":"系统环境 编译机器：Lenovo RUI7000 (i7-7700hq+8g DDRR4内存) 操作系统：Manjaro i3wm 18.0 ","date":"2018-05-28","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/:1:1","tags":["java","jdk","jvm"],"title":"一次失败的jdk编译","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/"},{"categories":["笔记"],"content":"软件环境 java虚拟机部分大多是C++代码，但类库都是由java写成的，所以编译JDK之前你首先需要有个jdk（嘿嘿，我编译我自己 所以编译环境需要以下依赖程序： bootstrap jdk：jdk1.8或jdk1.7 gcc，g++ 4.4+ (据官网说gcc版本最高只测试到7.4) 执行 sudo pacman -S java-8-openjdk gcc g++ ","date":"2018-05-28","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/:1:2","tags":["java","jdk","jvm"],"title":"一次失败的jdk编译","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/"},{"categories":["笔记"],"content":"下载源码 openjdk团队使用Mercurial工具管理源代码 安装: sudo pacman -S Mercurial 克隆代码 hg clone http://hg.openjdk.java.net/jdk8u/jdk8u/ clone完成后，进入源码目录，执行脚本 bash get_source.sh 会自动获取全部源码 如果下载太慢，可以使用github上的代码镜像 https://github.com/unofficial-openjdk/openjdk/ 注意：直接克隆整个仓库会下载所有版本jdk源码 ","date":"2018-05-28","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/:1:3","tags":["java","jdk","jvm"],"title":"一次失败的jdk编译","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/"},{"categories":["笔记"],"content":"编译 自动生成编译文件并检查依赖 bash ./configure 如果中途中断，请检查输出，安装对应的依赖库 执行编译命令 make all 如果成功会在所在文件夹下生成一个images的文件夹 然后我失败了QAQ 目前知道是遇到了一个已知bug，另外编译环境也炸了hhhh，下篇文章再说吧 咕咕咕 ","date":"2018-05-28","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/:2:0","tags":["java","jdk","jvm"],"title":"一次失败的jdk编译","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/"},{"categories":["杂谈"],"content":"昨天写Dockerfile那篇文章的时候，发下我的镜像中java有一个启动参数-Djava.security.egd=file:/dev/./urandom，我查了察相关资料，发现了些有趣的事情 ","date":"2018-05-28","objectID":"/posts/%E7%86%B5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/:0:0","tags":["Linux","密码学"],"title":"熵与随机数","uri":"/posts/%E7%86%B5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"categories":["杂谈"],"content":"随机数 关于这个参数，我们从随机数来说起 学过编程的同学应该都接触过随机数这个概念，虽然叫随机，但是大多数随机数生成实质上是通过一定的预先设定的算法计算出来的，根据密码学的原理，随机数的随机性检验有三个标准： 统计学伪随机性:统计学伪随机性指的是在给定的随机比特流样本中，1的数量大致等于0的数量，同理，“10”“01”“00”“11”四者数量大致相等。类似的标准被称为统计学随机性。满足这类要求的数字在人类“一眼看上去”是随机的。 密码学安全伪随机性: 其定义为，给定随机样本的一部分和随机算法，不能有效的演算出随机样本的剩余部分。 真随机性：其定义为随机样本不可重现。实际上只要给定边界条件，真随机数并不存在，可是如果产生一个真随机数样本的边界条件十分复杂且难以捕捉（比如计算机当地的本底辐射波动值），可以认为用这个方法演算出来了真随机数 相应的，随机数也分为三类： 伪随机数：满足第一个条件的随机数。 密码学安全的伪随机数：同时满足前两个条件的随机数。可以通过密码学安全伪随机数生成器计算得出。 真随机数：同时满足三个条件的随机数。 我们平时使用的大多数编程语言中所生成的随机数都是伪随机数，例如java中的Random类，可以使用时间戳作为随机种子，这种随机数足以满足我们大多数对随机数生成的需求，但是在一些特殊场合，例如在线交易中的id（这是区块链安全性中的重要一环，据我所知，有多起区块链攻击行为与区块链生成算法有缺陷有关），对随机数的安全性要求较高时，就要求达到密码学安全的伪随机数甚至真随机数，在java中，有一些提供安全随机数生成算法的类，例如org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom，在Tomcat7/8中，就使用了这个类用来产生seesion id，这个类中有一个种子生成器，他会根据配置来获取随机种子，在Tomcat中，会默认使用/dev/random返回的字符来作为种子，这个/dev/random 就是我们今天的主角。 ","date":"2018-05-28","objectID":"/posts/%E7%86%B5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/:1:0","tags":["Linux","密码学"],"title":"熵与随机数","uri":"/posts/%E7%86%B5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"categories":["杂谈"],"content":"Linux中的熵池 /dev/random是Linux中的一个真随机数生成器，这个生成器维护了一个熵池，Random方法会从熵池中取出字符串作为种子来产生随机数，我们的熵的大部分来于键盘、鼠标和磁盘 IO 数据这样的环境噪声，这些计算机活动所产生的熵会帮助随机数生成，在生成GPG秘钥的过程中，你可能会遇到如下提示： We need to generate a lot of random bytes. It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy. ++++++++++..+++++.+++++++++++++++.++++++++++...+++++++++++++++...++++++ +++++++++++++++++++++++++++++.+++++..+++++.+++++.+++++++++++++++++++++++++\u003e. ++++++++++\u003e+++++...........................................................+++++ Not enough random bytes available. Please do some other work to give the OS a chance to collect more entropy! (Need 290 more bytes) 但是假如我们的系统是一个服务器，我们没有鼠标和键盘输入。这意味着唯一的因素是你的磁盘IO。如果它是一个单独的、几乎不使用的磁盘，你将拥有较低的熵。另外一个问题是/dev/random是阻塞的，当你频繁生成随机数的时候，你可能会耗光你的熵池，/dev/random 会等待熵池收集到足够的环境噪声的时候才会继续生成随机数，这可能导致你的进程被长时间的挂起。在java 开发中，常常会遇到一些应用启动时间过长的问题，就可能是熵池空了导致线程阻塞了。 幸好Linux给我们提供了另外一个随机数生成器来解决这个问题。/dev/unrandom,这是一个伪随机数生成器，在缺乏熵的时候，他会复用熵池中的内容而不会导致阻塞，但是复用熵池会导致安全性下降，但是在安全性不强的情况下，可以考虑使用这个，比如我们可以使用-Djava.security.egd=file:/dev/./urandom这个java启动参数，来确保我们生成随机数的过程不被阻塞，这也回答了我们开头那个问题，java.security.egd是org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom的配置。 我们还可以用一些方法来影响熵池 $ cat /proc/sys/kernel/random/poolsize 4096 $ cat /proc/sys/kernel/random/entropy_avail 2975 使用这两个命令可以查看当前熵池的大小和熵池内有多少熵 我们可以通过一些方法来将熵池耗尽，比如将将/dev/random 定向到/dev/null中 $ cat /dev/random \u003e /dev/null \u0026 这样会快速的将熵池耗尽 如果我们想填充熵池呢，最好的办法是将处理器的抖动加入熵池中，我们可以安装Haveged来实现这一功能 $ sudo pacman -S Hacedged $ systemctl enable haveged $ systemctl start haveged 我们可以通过pv命令来观察熵池的增长速度 # 启用前 $ pv /dev/random \u003e /dev/null 25.0 B 0:00:03 [0.00 B/s] [ \u003c=\u003e # 启用后 $ pv /dev/random \u003e /dev/null 62MiB 0:00:03 [ 564KiB/s] [ \u003c=\u003e 可以观察到从几乎为0增长到了564kiB/s 参考： James J - /dev/[u]random：对熵的解释 chszs - Tomcat 8熵池阻塞变慢详解 ","date":"2018-05-28","objectID":"/posts/%E7%86%B5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/:2:0","tags":["Linux","密码学"],"title":"熵与随机数","uri":"/posts/%E7%86%B5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/"}]