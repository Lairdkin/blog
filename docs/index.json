[{"categories":null,"content":"该项目为博主毕业设计项目，项目已开源 代码开源于：点击查看代码 该系统设计了一个面向 IT 领域的线上招聘网站，目标客户为企业所定义的校招生群体。系统使用业界成熟的分布式微服务架构，将庞大臃肿的单实例项目以能为模块进行拆分，拆分后模块耦合度低，复用性好，对单个模块可以灵活的进行拓展。架构还支持了服务治理，持续集成等技术，提高了系统的稳定性。 系统包括了常见的岗位管理，简历管理，职位投递等功能，还提供了模拟笔试，供应聘者学习的专栏模块，为求职者提高招聘备考效率，为求职者和企业提供双向的招聘解决方案 ","date":"0001-01-01","objectID":"/projects/demoproject/:0:0","tags":null,"title":"在线招聘系统","uri":"/projects/demoproject/"},{"categories":[],"content":" 如果喜欢我的博客，可以考虑通过下面的方式支持一下哦~非常感激！ 所有资助的费用将被用于服务器的购买，域名的续费等支持 ","date":"2021-06-24","objectID":"/sponsor/:0:0","tags":[],"title":"支持我","uri":"/sponsor/"},{"categories":[],"content":"支持名单 昵称 渠道 金额 备注 *昆 支付宝 ￥10.24 *昆 Payal $10.24 HKD 如不想公开捐助信息可备注说明 ","date":"2021-06-24","objectID":"/sponsor/:0:1","tags":[],"title":"支持我","uri":"/sponsor/"},{"categories":["读书笔记"],"content":"简述了近日发表于biorxiv的“雄鼠怀孕”一文、孤雌生殖的代表“辉夜姬”，以及利用胚胎干细胞实现孤雌、孤雄生殖。","date":"2021-06-21","objectID":"/posts/parthenogenesis/","tags":["雄鼠怀孕","孤雌生殖","孤雄生殖","基因印记"],"title":"单性生殖”的读书笔记","uri":"/posts/parthenogenesis/"},{"categories":["读书笔记"],"content":"终于把考研分享的ppt做完了……有了一点点多余的时间，来学习一下最近很火的“单性生殖”吧。 最近一篇预印本文章很火，讲的是第二军医大通过构建相连的妊娠微环境，成功使雄性大鼠产生后代的故事。 简单来说呢，这个实验的第一步要先把一只经过去势（通俗来讲叫做“阉割”，去除睾丸、附睾、精囊等）的雄性大鼠和一只雌性大鼠通过手术结合在一起，构造一只人工“连体婴”（parabiont，连体生物）。构建这个模型的目的，是要让两只大鼠通过伤口的血管吻合共享血液，在雄性大鼠体内构造出“雌性微环境”（female microenvironment）。 成功构建出“连体婴”之后，第二步是要对其中的雄性大鼠进行子宫移植手术（uterus transplantation，UTx）。当然，移植的子宫来自其他雌性大鼠。（顺便一提，我发现他们在描述吻合右侧髂总静脉的时候，有一个iliac写成了lilac，髂变成了丁香……） 然后就到了第三步，也就是将囊胚期（胚胎发育的一个阶段，受精卵经过多次分裂，由称为“桑椹胚”的致密细胞团发育成具有空腔的胚泡）的胚胎植入两只大鼠的子宫内。 值得注意的是，为了在雄性大鼠体内构造出妊娠所需的血液环境，在移植前三天需要让经过输精管结扎的雄鼠与雌性“连体婴”交配，使雌性进入假孕状态。之后，就是从另外的雌性大鼠身上采集胚泡，进行胚胎移植。 随后的统计显示，有30.07%的胚胎在雌性子宫中正常发育，而对应的雄性数据为9.64%；并且有54.35%的“连体婴”均未产生正常胚胎，而雌性未怀孕的“连体婴”中的雄性一定不会怀孕，反之则不然。因此，研究者推测雌性怀孕是雄性怀孕的必要条件，胚胎只有在接触怀孕雌性的血液时，才能在雄性子宫中正常发育。 然后，故事讲到了最后一步。在胚胎发育至21.5天（ED21.5）时，研究者对所有的实验个体进行剖宫产，观察胎儿发育情况。在雄性大鼠产下的胎儿中出现了一些异常的死胎（而在ED18.5的手术中没有发现异常，因此推测这种异常发生于胚胎发育晚期），而其他活胎的各项主要指标与正常交配的雌鼠、“连体婴”雌鼠相比均无明显差异。 最终的数据表明，在280枚移植给雄鼠的胚胎中，有10只存活到了成年。 以上就是这篇文章的主要内容，我们不难看出，这篇文章主要试图讲述的故事是“雄鼠怀孕”，具体方法是用“连体婴”和UTx构造出一个容器，再移植成熟的胚泡进去。 而最近又被拿出来和这篇文章做比较的“辉夜姬”（kaguya，我老是想到輝夜の城で踊りたい），其核心是通过重构卵母细胞发育出可存活的孤雌生殖小鼠个体，二者的关系大概就是“容器”和“内容物”的关系吧。 那么既然说到了“辉夜姬”，就再把它相关的东西也来学习一下吧。 首先我们要注意，相比发表在预印本网站上、未经过同行评议的“雄鼠怀孕”研究，“辉夜姬”的研究在2004年以Letter形式发表于Nature，此后更进一步的研究在2007年发表于Nature biotechnology。 在介绍“辉夜姬”之前，我们要先了解一个前置知识，是什么让哺乳动物失去了孤雌生殖的能力？目前的主流观点是“基因印记”的存在，即一个等位基因在父本和母本来源中存在不同的表达。 举个例子吧，比如说有一个基因叫做Igf2，它的DNA甲基化（在DNA的嘧啶上进行甲基修饰，是控制基因转录的重要机制，高甲基化不利于基因表达）模式在精子和卵子中有所区别。这种区别使得两性生殖细胞中的Igf2表达存在差异，从而阻止了孤雌生殖。 研究人员基于“基因印记的存在是孤雌生殖的障碍”这一思路，使用H19基因缺失13kb（阻断H19等位基因表达、增强母系Igf2表达）的小鼠卵母细胞作为未发育（Ng）组，与完全发育（Fg）组构建孤雌胚胎（NgH19Δ13/Wgwt）。 如果再捋一下的话大概意思就是，正常情况下H19是父系下调、Igf2是母系下调，而H19Δ13在卵母细胞中“制造”出了类似父系的这两个基因的表达情况，即H19表达下调、Igf2表达上调。因此，NgH19Δ13/Wgwt基因型的胚胎就拥有了类似父系和母系结合的基因表达情况。（捋对没有啊我自己都晕了…… 之后的实验证实，这些孤雌胚胎被移植到雌鼠子宫中后，最多发育到第17.5天便不会继续发育。在第19.5天的10只活胎中，有两只存活了下来（存活率0.5%），其中一只长大成“人”，就是大名鼎鼎的“辉夜姬”。 之后，“辉夜姬”（是一只漂亮的“小黑”C57）成功交配并产下了正常的幼崽。她自2003.2.3降生，共存活了793天。之后，研究者们制造出了更多的双母小鼠，研究发现其平均寿命比对照组长186天。 而在文章的最后，作者推测另外两个基因Gtl2（异常下调）与Dlk1（异常上调）的表达异常可能是阻止小鼠孤雌生殖的障碍，为下一篇文章埋下了伏笔。 在2007年的文章中，作者认为H19Δ13的效率实在太低（371个细胞就活了俩……），因此采用了H19和Dlk1（还记得上一篇文章的Dlk1吗？）的双敲除小鼠，由其构建的胚胎被命名为NgΔDouble/fg。 研究者们构建了323枚重组胚胎，最终有27只幼崽活到了成年，其中有5只接受了繁殖能力测试，并产下了遗传正常的幼鼠。 在此后的表型测试中，双母小鼠除了出生后体重较低、IG-DMR缺失以外，在表型上与野生型小鼠并无不同。 这一研究最大的意义在于阐明了孤雌生殖的唯一屏障——基因印记。研究表明，只要通过技术手段“擦除”基因印记，就可能产生正常的双母小鼠。 之前有人认为，缺乏精子RNA一类的男性来源的因子可能是体细胞核移植成功率低的原因。然而这一研究表明，配子融合后精子特异的转录本哺乳动物的发育并无必要。 以上，由“辉夜姬”开启的孤雌生殖小鼠研究的介绍总算告一段落……会有人看到这儿吗？ 而在查找“辉夜姬”相关资料时，我顺便发现了由我国科学家制造出的第一例孤雄生殖小鼠……这不说说有点过意不去吧？那就来吧。 与以“辉夜姬”为代表的使用未成熟卵母细胞进行孤雌生殖的研究不同，发表于Cell stem cell上的这篇文章采用了单倍体胚胎干细胞（HaESCs，只含有一套染色体、具有多向分化能力的细胞，包括孤雌的phESCs和孤雄的ahESCs）。 与卵母细胞和精子相比，HaESCs呈现出整体上的低甲基化，其模式类似于原始生殖细胞（PGCs，未分化为精子或卵子的生殖细胞）。 科学家一拍大腿（没有），我们费了那么大劲来“擦除”基因印记，现在居然有现成的低甲基化送上门！于是，他们利用老朋友CRISPER-Cas9删除了phESCs中的H19、IG（Dlk1）和Rasgrf1的印记区域（比2KO多一个Rasgrf1），产生了3KO-phESCs。 然后将得到的3KO-phESCs注入到MII卵母细胞（位于第二次减数分裂中期的卵母细胞）中，总而言之一通操作之后就产生了来自phESCs的双母小鼠。 随后的表型检测证明，相较于2KO小鼠，3KO小鼠的活动距离、运动速度、生长曲线恢复了正常（与野生型相比无明显差异），显示额外敲除Rasgrf1印记区能够有效改善双母小鼠的表型。 然后，注意，费劲的地方来了——研究者们显然不满足于制造表型改善的双母小鼠，他们开始向着孤雄生殖进军了。 但孤雄生殖的难度远大于孤雌，首先，ahESCs中的印记区域多于phESCs；其次，phESCs注射进MII卵母细胞就完事儿了，但ahESCs需要一个去核的卵细胞，再将其与另一只雄鼠的精子一同注入。 研究者们先选取了六个（这已经比3KO多一倍了），然而制造出来的6KO-ahESCs最多只能发育到ED8.5，远不能满足活产的要求。 之后，研究者们又试图将6KO-ahESCs与精子共注射，通过四倍体互补产生双父小鼠。这次小鼠倒是造出来了，但所有的小鼠都有严重的过度生长和水肿，出生后不久便死于哺乳、呼吸困难，即使活到足月体内的压力也明显更高。 这显然是敲得还不够啊——研究者们又发现，6KO小鼠的Gnas印记区有明显的低甲基化。在试着敲除Gnas印记区的外显子、生成7KO-ahESCs后，他们终于从477个囊胚中得到了12只7KO双父小鼠。 相比于6KO，7KO小鼠在体重、体内压方面的表型得到了显著改善，有两只小鼠活过了48h，但没有一只活到成年。 这项研究除了最引人注目的“孤雄生殖”，也证明了仅靠广泛甲基化的HaESCs是不足以满足单性生殖的要求的，必须要对其进行修饰。 至于为什么孤雄繁殖的小鼠表型异常、无法存活，研究者用“冲突理论”加以解释，即认为母亲与后代间存在资源竞争关系，父系基因组促进后代生长、母系基因组阻碍后代生长。 （细想想还挺有道理的……怀孕的是母亲，身体的资源一共就那么多，确实存在竞争关系啊。 我的读书笔记到此就结束了，一晚上的时间就耗在这东西上，下次绝对不这么干了x 参考文献： [1]A rat model of pregnancy in the male parabiont, Rongjia Zhang, Yuhuan Liu, bioRxiv, 2021.06.09.447686 [2]Kono T, Obata Y, Wu Q, et al. Birth of parthenogenetic mice that can develop to adulthood. Nature. 2004;428(6985):860-864. [3]Kawahara M, Wu Q, Takahashi N, et al. High-frequency generation of viable mice from engineered bi-maternal embryos. Nat Biotechnol. 2007;25(9","date":"2021-06-21","objectID":"/posts/parthenogenesis/:0:0","tags":["雄鼠怀孕","孤雌生殖","孤雄生殖","基因印记"],"title":"单性生殖”的读书笔记","uri":"/posts/parthenogenesis/"},{"categories":[],"content":" 新番 \r\r\r 完结 \r\r\r\r","date":"2021-06-19","objectID":"/bangumi/:0:0","tags":[],"title":"追番","uri":"/bangumi/"},{"categories":["其他"],"content":"萝卜的狒狒14国际服日常漫画，By 合子 ","date":"2021-06-17","objectID":"/posts/ff14-cartoon/:0:0","tags":["漫画"],"title":"【补档】萝卜的狒狒国际服漫画","uri":"/posts/ff14-cartoon/"},{"categories":["其他"],"content":"礼物 ","date":"2021-06-17","objectID":"/posts/ff14-cartoon/:1:0","tags":["漫画"],"title":"【补档】萝卜的狒狒国际服漫画","uri":"/posts/ff14-cartoon/"},{"categories":["其他"],"content":"做主线 ","date":"2021-06-17","objectID":"/posts/ff14-cartoon/:2:0","tags":["漫画"],"title":"【补档】萝卜的狒狒国际服漫画","uri":"/posts/ff14-cartoon/"},{"categories":["其他"],"content":"黑天马 ","date":"2021-06-17","objectID":"/posts/ff14-cartoon/:3:0","tags":["漫画"],"title":"【补档】萝卜的狒狒国际服漫画","uri":"/posts/ff14-cartoon/"},{"categories":["其他"],"content":"考试 ","date":"2021-06-17","objectID":"/posts/ff14-cartoon/:4:0","tags":["漫画"],"title":"【补档】萝卜的狒狒国际服漫画","uri":"/posts/ff14-cartoon/"},{"categories":["前端笔记"],"content":"转载信息 转自：掘金 by 小蘑菇哥哥 ，原标题：谨慎处理 Service Worker 的更新 今天要聊的话题是前端最近的一个更新方向 PWA 中的核心 Service Worker 的更新问题。这是一个很容易被开发者忽略的问题，因为绝大部分开发者可能对它还不太熟悉。 Service Worker 以其 异步安装 和 持续运行 两个特点，决定了针对它的更新操作必须非常谨慎小心。因为它具有拦截并处理网络请求的能力，因此必须做到网页(主要是发出去的请求)和 Service Worker 版本一致才行，否则就会导致新版本的 Service Worker 处理旧版本的网页，或者一个网页先后由两个版本的 Service Worker 控制引发种种问题。 经过近 2 年的发展，PWA 在 WEB 圈的知名度已经大大提升，即便你没用过可能也至少听说过。Service Worker （以下简称 SW）是 PWA 中最复杂最核心的部分，其中涉及的主要有 Caches API (caches.put, caches.addAll 等), Service Worker API (self.addEventListener, self.skipWaiting 等) 和 Registration API (reg.installing, reg.onupdatefound 等)。 本文不再科普 SW 的基础，我主要想在这里谈一谈 SW 的更新问题。需要做到 SW 和页面的完全同步，其实并不容易。在此之前，我假设你已经了解了： SW 的作用 SW 的注册方式 (navigator.serviceWorker.register) SW 的生命周期 (install -\u003e waiting -\u003e activate -\u003e fetch) ","date":"2021-06-09","objectID":"/posts/service-worker-update/:0:0","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"组织 SW 的两大禁忌 在开始正式谈论 SW 的更新机制之前，我们有必要先确定组织 SW 时的两个禁忌。在将 SW 应用到自己的站点时，我们要避开这两种方法，他们是： ","date":"2021-06-09","objectID":"/posts/service-worker-update/:1:0","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"不要给 service-worker.js 设置不同的名字 一般针对静态文件，时下流行的做法是在每次构建时根据内容（或者当时的时间等随机因素）给它们一个唯一的命名，例如 index.[hash].js。因为这些文件不常修改，再配以长时间的强制缓存，能够大大降低访问它们的耗时。 可惜针对 SW，这种做法并不合适。我们假设一个项目 首页 index.html，底下包含了一段 \u003cscript\u003e 用于注册 service-worker.v1.js。 为了提升速度或者离线可用，这个 service-worker.v1.js 会把 index.html 缓存起来。 某次升级更新之后，现在 index.html 需要配上 service-worker.v2.js 使用了，所以源码中底下的 \u003cscript\u003e 中修改了注册的地址。 但我们发现，用户访问站点时由于旧版 service-worker.v1.js 的作用，从缓存中取出的 index.html 引用的依然是 v1，并不是我们升级后引用 v2。 之所以出现这种情况，是因为把 v1 升级为 v2 依赖于 index.html 引用地址的变化，但它本身却被缓存了起来。一旦到达这种窘境，除非用户手动清除缓存，卸载 v1，否则我们无能为力。 所以 service-worker.js 必须使用相同的名字，不能在文件名上加上任何会改变的因素。 ","date":"2021-06-09","objectID":"/posts/service-worker-update/:1:1","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"不要给 service-worker.js 设置缓存 理由和第一点类似，也是为了防止在浏览器需要请求新版本的 SW 时，因为缓存的干扰而无法实现。毕竟我们不能要求用户去清除缓存。因此给 SW 及相关的 JS (例如 sw-register.js，如果独立出来的话)设置 Cache-control: no-store 是比较安全的。 ","date":"2021-06-09","objectID":"/posts/service-worker-update/:1:2","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"SW 的 waiting 状态 注册 SW 是通过 navigator.serviceWorker.register(swUrl, options) 方法进行的。但和普通的 JS 代码不同，这句执行在浏览器看来其实有两种不同的情况： 如果目前尚未有活跃的 SW ，那就直接安装并激活。 如果已有 SW 安装着，向新的 swUrl 发起请求，获取内容和和已有的 SW 比较。如没有差别，则结束安装。如有差别，则安装新版本的 SW（执行 install 阶段），之后令其等待（进入 waiting 阶段） 此时当前页面会有两个 SW，但状态不同，如下图： 如果老的 SW 控制的所有页面 全部关闭，则老的 SW 结束运行，转而激活新的 SW（执行 activated 阶段），使之接管页面。 这是一种比较温和和安全的做法，相当于新旧版本的自然淘汰。但毕竟关闭所有页面是用户的选择而不是程序员能控制的。另外我们还需注意一点：由于浏览器的内部实现原理，当页面切换或者自身刷新时，浏览器是等到新的页面完成渲染之后再销毁旧的页面。这表示新旧两个页面中间有共同存在的交叉时间，因此简单的切换页面或者刷新是不能使得 SW 进行更新的，老的 SW 依然接管页面，新的 SW 依然在等待。（这点也要求我们在检测 SW 更新时，除了 onupdatefound 之外，还需要判断是否存在处在等待状态的 SW，即 reg.waiting 是否存在。不过这在本文讨论范围之外，就不展开了） 假设我们提供了一次重大升级，希望新的 SW 尽快接管页面，应该怎么做呢？ ","date":"2021-06-09","objectID":"/posts/service-worker-update/:2:0","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"方法一：skipWaiting 在遭遇突发情况时，很容易想到通过“插队”的方式来解决问题，现实生活中的救护车消防车等特种车辆就采用了这种方案。SW 也给程序员提供了实现这种方案的可能性，那就是在 SW 内部的 self.skipWaiting() 方法。 self.addEventListener('install', event =\u003e { self.skipWaiting() // 预缓存其他静态内容 }) 复制代码 这样可以让新的 SW “插队”，强制令它立刻取代老的 SW 控制所有页面，而老的 SW 被“斩立决”，简单粗暴。Lavas 最初就使用了这个方案，因为实在是太容易想到也太容易实现了，诱惑极大。 可惜这个方案是有隐患的。我们想象如下场景： 一个页面 index.html 已安装了 sw.v1.js （实际地址都是 sw.js，只是为了明显区分如此表达而已） 用户打开这个页面，所有网络请求都通过了 sw.v1.js，页面加载完成。 因为 SW 异步安装的特性，一般在浏览器空闲时，他会去执行那句 navigator.serviceWorker.register。这时候浏览器发现了有个 sw.v2.js 存在，于是安装并让他等待。 但因为 sw.v2.js 在 install 阶段有 self.skipWaiting()，所以浏览器强制退休了 sw.v1，而是让 sw.v2 马上激活并控制页面。 用户在这个 index.html 的后续操作如有网络请求，就由 sw.v2.js 处理了。 很明显，同一个页面，前半部分的请求是由 sw.v1.js 控制，而后半部分是由 sw.v2.js 控制。这两者的不一致性很容易导致问题，甚至网页报错崩溃。比如说 sw.v1.js 预缓存了一个 v1/image.png，而当 sw.v2.js 激活时，通常会删除老版本的预缓存，转而添加例如 v2/image.png 的缓存。所以这时如果用户网络环境不畅或者断网，或者采用的是 CacheFirst 之类的缓存策略时，浏览器发现 v1/image.png 已经在缓存中找不到了。即便网络环境正常，浏览器也得再发一次请求去获取这些本已经缓存过的资源，浪费了时间和带宽。再者，这类 SW 引发的错误很难复现，也很难 DEBUG，给程序添加了不稳定因素。 除非你能保证同一个页面在两个版本的 SW 相继处理的情况下依然能够正常工作，才能使用这个方案。 ","date":"2021-06-09","objectID":"/posts/service-worker-update/:3:0","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"方法二：skipWaiting + 刷新 方法一的问题在于，skipWaiting 之后导致一个页面先后被两个 SW 控制。那既然已经安装了新的 SW，则表示老的 SW 已经过时，因此可以推断使用老的 SW 处理过的页面也已经过时。我们要做的是让页面从头到尾都让新的 SW 处理，就能够保持一致，也能达成我们的需求了。所以我们想到了刷新，废弃掉已经被处理过的页面。 在注册 SW 的地方（而不是 SW 里面）可以通过监听 controllerchange 事件来得知控制当前页面的 SW 是否发生了变化，如下： navigator.serviceWorker.addEventListener('controllerchange', () =\u003e { window.location.reload(); }) 复制代码 当发现控制自己的 SW 已经发生了变化，那就刷新自己，让自己从头到尾都被新的 SW 控制，就一定能保证数据的一致性。道理是对，但突然的更新会打断用户的操作，可能会引发不适。刷新的源头在于 SW 的变更；SW 的变更又来源于浏览器安装新的 SW 碰上了 skipWaiting，所以这次刷新绝大部分情况会发生在加载页面后的几秒内。用户刚开始浏览内容或者填写信息就遇上了莫名的刷新，可能会砸键盘。 另外这里还有两个注意点： ","date":"2021-06-09","objectID":"/posts/service-worker-update/:4:0","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"SW 的更新和页面的刷新 在讲到 SW 的 waiting 状态时，我曾经说过 简单的切换页面或者刷新是不能使得 SW 进行更新的，而这里又一次牵涉到了 SW 的更新和页面的刷新，不免产生混淆。 我们简单理一下逻辑，其实也不复杂： 刷新不能使得 SW 发生更新，即老的 SW 不会退出，新的 SW 也不会激活。 这个方法是通过 skipWaiting 迫使 SW 新老交替。在交替完成后，通过 controllerchange 监听到变化再执行刷新。 所以两者的因果是相反的，并不矛盾。 ","date":"2021-06-09","objectID":"/posts/service-worker-update/:4:1","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"避免无限刷新 在使用 Chrome Dev Tools 的 Update on Reload 功能时，使用如上代码会引发无限的自我刷新。为了弥补这一点，需要添加一个 flag 判断一下，如下： let refreshing = false navigator.serviceWorker.addEventListener('controllerchange', () =\u003e { if (refreshing) { return } refreshing = true; window.location.reload(); }); 复制代码 ","date":"2021-06-09","objectID":"/posts/service-worker-update/:4:2","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"方法三：给用户一个提示 方法二有一个思路值得借鉴，即“通过 SW 的变化触发事件，而在事件监听中执行刷新”。但毫无征兆的刷新页面的确不可接受，所以我们再改进一下，给用户一个提示，让他来点击后更新 SW，并引发刷新，岂不美哉？ 大致的流程是： 浏览器检测到存在新的（不同的）SW 时，安装并让它等待，同时触发 updatefound 事件 我们监听事件，弹出一个提示条，询问用户是不是要更新 SW 如果用户确认，则向处在等待的 SW 发送消息，要求其执行 skipWaiting 并取得控制权 因为 SW 的变化触发 controllerchange 事件，我们在这个事件的回调中刷新页面即可 这里值得注意的是第 3 步。因为用户点击的响应代码是位于普通的 JS 代码中，而 skipWaiting 的调用位于 SW 的代码中，因此这两者还需要一次 postMessage 进行通讯。 代码方面，我们以 Lavas 的实现来分步骤看一下： 第 1 步是浏览器执行的，与我们无关。第 2 步需要我们监听这个 updatefound 事件，这是需要通过注册 SW 时返回的 Registration 对象来监听的，因此通常我们可以在注册时直接监听，避免后续还要再去获取这个对象，徒增复杂。 function emitUpdate() { var event = document.createEvent('Event'); event.initEvent('sw.update', true, true); window.dispatchEvent(event); } if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/service-worker.js').then(function (reg) { if (reg.waiting) { emitUpdate(); return; } reg.onupdatefound = function () { var installingWorker = reg.installing; installingWorker.onstatechange = function () { switch (installingWorker.state) { case 'installed': if (navigator.serviceWorker.controller) { emitUpdate(); } break; } }; }; }).catch(function(e) { console.error('Error during service worker registration:', e); }); } 复制代码 这里我们通过发送一个事件 (名为 sw.update，位于 emitUpdate() 方法内) 来通知外部，这是因为提示条是一个单独的组件，不方便在这里直接展现。当然如果你的应用有不同的结构，也可以自行修改。总之想办法展示提示条，或者单纯使用 confirm 让用户确认即可。 第 3 步需要处理用户点击，并和 SW 进行通讯。处理点击的代码比较简单，就不重复了，这里主要列出和 SW 的通讯代码： try { navigator.serviceWorker.getRegistration().then(reg =\u003e { reg.waiting.postMessage('skipWaiting'); }); } catch (e) { window.location.reload(); } 复制代码 注意通过 reg.waiting 向 等待中的 SW 发消息，而不是向当前的老的 SW 发消息。而 SW 部分则负责接收消息，并执行“插队”逻辑。 // service-worker.js // SW 不再在 install 阶段执行 skipWaiting 了 self.addEventListener('message', event =\u003e { if (event.data === 'skipWaiting') { self.skipWaiting(); } }) 复制代码 第 4 步和方法二一致，也是通过 navigator.serviceWorker 监听 controllerchange 事件来执行刷新操作，这里就不重复列出代码了。 ","date":"2021-06-09","objectID":"/posts/service-worker-update/:5:0","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"方法三的弊端 从运行结果上看，这个方法兼顾了快速更新和用户体验，是当前最好的解决方案。但它也有弊端。 ","date":"2021-06-09","objectID":"/posts/service-worker-update/:6:0","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"弊端一：过于复杂 在文件数量方面，涉及到至少 2 个文件（注册 SW，监听 updatefound 和处理 DOM 的展现和点击在普通的 JS 中，监听信息并执行 skipWaiting 是在 SW 的代码中），这还不算我们可能为了代码的模块分离，把 DOM 的展现点击和 SW 的注册分成两个文件 在 API 种类方面，涉及到 Registration API（注册，监听 updatefound 和发送消息时使用），SW 生命周期和 API（skipWaiting）以及普通的 DOM API 测试和 DEBUG 方法复杂，至少需要制造新老 2 个版本 SW 的环境，并且熟练掌握 SW 的 DEBUG 方式。 尤其是为了达成用户点击后的 SW “插队”，需要从 DOM 点击响应，到发送消息给 SW，再到 SW 里面操作。这一串操作横跨好几个 JS，非常不直观且复杂。为此已有 Google 大佬 Jake Archibald 向 W3C 提出建议，简化这个过程，允许在普通的 JS 中通过 reg.waiting.skipWaiting() 直接插队，而不是只能在 SW 内部操作。 ","date":"2021-06-09","objectID":"/posts/service-worker-update/:6:1","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"弊端二：必须通过 JS 完成更新 这里指的是 SW 的更新只能通过用户点击通知条上的按钮，使用 JS 来完成，而 不能通过浏览器的刷新按钮完成。这其实是浏览器的设计问题，而非方案本身的问题。 不过反过来说，如果浏览器帮助我们完成了上述操作，那就变成允许通过一个 Tab 的刷新去强制其他 Tab 刷新，在当前浏览器以 Tab 为单位的前提下，存在这种交叉控制也是不安全和难以理解的。 唯一可行的优化是当 SW 控制的页面仅存在一个 Tab 时，刷新这个 Tab 如果能够更新 SW，也能给我们省去不少操作，也不会带来交叉控制的问题。只是这样可能加重了浏览器的判断成本，也丧失了操作一致性的美感，只能说这可能也是一个久远的梦想了。 ","date":"2021-06-09","objectID":"/posts/service-worker-update/:6:2","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"后记 SW 的功能相当强大，但同时涉及的 API 也相对较多，是一个需要投入相当学习成本的强力技术（国外文章称之为 rocket science）。SW 的更新对使用 SW 的站点来说非常重要，但如上所述，其方案也相对复杂，远远超过了其他常用前端基础技术的复杂度（例如 DOM API，JS 运算，闭包等等）。不过 SW 从其起步至今也不过两三年的时间，尚处在发展期。相信通过 W3C 的不断修正以及前端圈的持续使用，会有更加简洁，更加自动，更加完备的方案出现，届时我们可能就能像使用 DOM API 那样简单地使用 SW 了。 ","date":"2021-06-09","objectID":"/posts/service-worker-update/:7:0","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["前端笔记"],"content":"参考文章 有关 Service Worker 更新的两点改进 - 编写本文的源头 The Service Worker Lifecycle - 来自 Google Developers 的 Service Worker 科普文章之一 How to Fix the Refresh Button When Using Service Workers - 提及了第四种方法，不过在 Firefox 中仍有兼容性问题 ","date":"2021-06-09","objectID":"/posts/service-worker-update/:8:0","tags":["service worker","pwa"],"title":"[转]处理service worker 更新的常用方法","uri":"/posts/service-worker-update/"},{"categories":["笔记"],"content":"转载信息 转自：Anhlaidh的github ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:0:0","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"Maven ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:1:0","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"Junit ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:2:0","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"测试 单元测试：对软件中最小可测试单元进行检查和验证，通常是一个函数/方法（属于白盒测试） 集成测试： 将多个单元相互作用，形成一个整体，对整体协调性进行测试 白盒测试： 全面了解程序内部逻辑结构，对所有的逻辑路径都进行测试，一般由程序员完成 黑盒测试：又名功能测试，将程序看作不可打开的盒子，一般由独立使用者完成 自动测试：用程序批量、反复的测试程序，并可自动检查程序结果是否满足预定的要求 手动测试：手动执行程序，手动输入所需要的参数，手动检查程序结果是否满足预定的要求 回归测试：修改旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误 深入学习：软件测试-基于问题驱动模式 朱少民 Junit import static 导入该包内的所有静态方法，使用时可不加类名 Triangle package JavaLearning_Advanced.Maven; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 13:42 */ public class Triangle { public boolean judgeEdges(int a, int b, int c) { boolean result = true; //边长非负性 if (a \u003c= 0 || b \u003c= 0 || c \u003c= 0) { return false; } //两边和大于第三边 if (a+b\u003c=c) { return false;} if (b+c\u003c=a) { return false;} if (c+a\u003c=b) { return false;} return true; } } testTriangle import JavaLearning_Advanced.Maven.Triangle; import org.junit.Test; import static org.junit.Assert.*; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 13:44 */ public class testTriangle { @Test public void test() { assertEquals(false,new Triangle().judgeEdges(1,2,3)); } } 深入学习：Junit实战（第二版），PetarTahchiey ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:2:1","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"Java字符编码 尽可能使用UTF-8 读取写入编码保持一致 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:3:0","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"国际化 Locale 方法 getAvailableLocales()获取所有可用的locale getDefault()返回默认的Locale native2ascii.exe ResourceBundle 根据Locale要求，加载语言文件 存储语言集合中的K-V对 getString(String key) 返回对应的value package JavaLearning_Advanced.International; import java.util.Locale; import java.util.ResourceBundle; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 14:34 */ public class HelloWorld { public static void main(String[] args) { //取得系统默认的国家/语言环境 Locale myLocale = Locale.getDefault(); System.out.println(myLocale);//zh_CN //根据指定语言，国家环境，加载资源文件 ResourceBundle bundle = ResourceBundle.getBundle(\"message\", myLocale); //从资源文件中获取信息 System.out.println(bundle.getString(\"hello\")); } } ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:4:0","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"高级字符编码 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:5:0","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"正则表达式 学习正则表达式： 精通正则表达式（第三版） Jefferry E.F.Friedl java.util.regex包 Pattern 正则表达式的编译表示 compile编译一个正则表达式喂Pattern对象 matcher用Pattern对象匹配一个字符串，返回匹配结果 Matcher IndexMethod(位置方法) //start(),start(int group),end(),end(group) StudyMethod(查找方法) //lookingAt(),find(),find(int start),matches() Replacement(替换方法) //replaceAll(String replacement) Matcher package JavaLearning_Advanced.regex; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 19:21 */ public class MatcherDemo { private static final String REGEX = \"\\\\bdog\\\\b\";//\\b表示边界 private static final String INPUT = \"dog dog dog doggie dogg\"; public static void main(String[] args) { //检查字符串里有多少个dog Pattern pattern = Pattern.compile(REGEX); Matcher matcher = pattern.matcher(INPUT); int count = 0; while (matcher.find()) { count++; System.out.println(\"Match number\" + count); System.out.println(\"start()\" + matcher.start()); System.out.println(\"end()\" + matcher.end()); // String f = \"fooooooooooooo\"; // matcher.lookingAt();//不完全匹配,匹配foo为true // matcher.find();//完全匹配，匹配foo为false } } } Replace package JavaLearning_Advanced.regex; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 19:39 */ public class ReplaceDemo { public static void Replace_1() { String REGEX = \"a*b\";//*表示限定前面的a可以有0个或者多个 String INPUT = \"aavfooabfooabafoobcdd\"; String REPLACE = \"-\"; Pattern pattern = Pattern.compile(REGEX); Matcher matcher = pattern.matcher(INPUT); StringBuffer stringBuffer = new StringBuffer(); // 全部替换 while (matcher.find()) { matcher.appendReplacement(stringBuffer, REPLACE); } //最后将尾巴字符串附加上 matcher.appendTail(stringBuffer); System.out.println(stringBuffer.toString()); } public static void Replace_2() { String REGEX = \"dog\";//*表示限定前面的a可以有0个或者多个 String INPUT = \"The dog says meow.All dogs say meow\"; String REPLACE = \"cat\"; Pattern pattern = Pattern.compile(REGEX); Matcher matcher = pattern.matcher(INPUT); INPUT = matcher.replaceAll(REPLACE); System.out.println(INPUT); } } OJ package JavaLearning_Advanced.regex; import org.apache.commons.io.Charsets; import org.apache.commons.io.IOUtils; import java.io.InputStream; import java.nio.charset.Charset; import java.util.LinkedList; import java.util.List; import java.util.Scanner; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 19:55 */ public class String2inputStream { public static void main(String[] args) { //构造字符串列表 List\u003cString\u003e names = new LinkedList\u003c\u003e(); names.add(\"xiaohong\"); names.add(\"xiaoming\"); names.add(\"Daming\"); names.add(\"xiaohei\"); //合并为一个字符串，以逗号相连 String nameStr = String.join(\",\", names); //将字符串作为默认输入流 InputStream in = IOUtils.toInputStream(nameStr, Charsets.toCharset(\"UTF-8\")); //重置系统的输入流 System.setIn(in); //模拟键盘输入，这也是OJ平台测试用例输入的原理 //此处也可以换成一个文件的输入流 Scanner scanner = new Scanner(System.in); scanner.useDelimiter(\",\"); while (scanner.hasNext()) { System.out.println(scanner.next()); } } } ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:5:1","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"xml 常规语法 任何的起始标签都必须有一个结束标签 简化写法，例如，可以写为 大小写敏感，name和Name不一样 每个文件都要有一个根元素 标签必须按合适的顺序进行嵌套，不可错位 所有的特性都必须有值，且在值的周围加上引号 需要转义字符，如\"\u003c“需要用\u003c代替 转义 符号 意思 \u0026lt; \u003c 小于 \u0026gt; \u003e 大于 \u0026amp; \u0026 和号 \u0026apos; ' 单引号 \u0026quot; \" 双引号 注释：\u003c!– 内容 –\u003e ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:6:0","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"xml解析 未完成 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:6:1","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"JSON 概念 JavaScript Object Notation ，JS对象表示法 是一种轻量级的数据交换格式 类似XML，更小、更快、更易解析 最早用于JavaScript中，容易解析，最后推广到全语言 尽管使用JavaScript语法，但是独立于编程语言 用途 JSON生成 JSON解析 JSON校验 和JavaBean对象进行互解析 具有一个无参的构造函数 可以包括多个属性，所有属性都是private 每个属性都有对应的Getter/Setter方法 JavaBean 用于封装数据，有可称为POJO(Plain Old notes.Java Object) package JavaLearning_Advanced.Json; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.File; import java.io.IOException; import java.util.Arrays; import java.util.List; /** * @Description: * @author: Anhlaidh * @date: 2020/3/26 0026 21:42 */ public class testJackson { public static void main(String[] args) throws IOException { testJsonObject(); System.out.println(\"分割线=====================================================\"); testJsonFile(); } private static void testJsonFile() throws IOException { ObjectMapper objectMapper = new ObjectMapper(); //从json文件中加载，并重构为java对象 File json = new File(\"temp/json/books.json\"); List\u003cBook\u003e books = objectMapper.readValue(json, new TypeReference\u003cList\u003cBook\u003e\u003e() { }); for (Book book : books) { System.out.println(book.getAuthor()); System.out.println(book.getTitle()); } } private static void testJsonObject() throws IOException { ObjectMapper objectMapper = new ObjectMapper(); //构造对象 Person person = new Person(); person.setName(\"TOM\"); person.setAge(20); person.setScores(Arrays.asList(60, 70, 80)); //将对象解析为json字符串 String jsonStr = objectMapper.writeValueAsString(person); System.out.println(jsonStr); //json字符串重构对象 Person p2 = objectMapper.readValue(jsonStr, Person.class); System.out.println(p2.getName()); System.out.println(p2.getAge()); System.out.println(p2.getScores()); //从json字符串重构JsonNode对象 JsonNode node = objectMapper.readTree(jsonStr); System.out.println(node.get(\"name\").asText()); System.out.println(node.get(\"age\").asText()); System.out.println(node.get(\"scores\")); } } [ { \"category\": \"COOKING\", \"tools.title\": \"Everyday Italian\", \"author\": \"Giada De Laurentiis\", \"year\": \"2005\", \"price\": 30 }, { \"category\": \"CHILDREN\", \"tools.title\": \"Harry Potter\", \"author\": \"J K Rowling\", \"year\": \"2005\", \"price\": 29 }, { \"category\": \"WEB\", \"tools.title\": \"Learning XML\", \"author\": \"Erik T.Ray\", \"year\": \"2003\", \"price\": 39 } ] 总结 JSON是一种独立于编程语言的、轻量的、数据交换格式 有多种第三方库辅助我们进行JSON生成和解析 JSON会丢失顺序性 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:7:0","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"图片 - imageIO - 验证码 package JavaLearning_Advanced.picture; import javax.imageio.ImageIO; import java.awt.*; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.Random; /** * @Description: * @author: Anhlaidh * @date: 2020/3/28 0028 19:56 */ public class ValidateCode { static char[] codeSequence= {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','2','3','4','5','6','7','8','9'}; static int charNum = codeSequence.length; public static void main(String[] args) throws IOException { generateCode(\"./temp/validateCode/code.jpg\"); } private static void generateCode(String filePath) throws IOException { //首先定义验证码图片库 int width = 140;//验证码图片的宽度 int height = 40;//验证码图片的高度 BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); //定义图片上的图形和干扰线 Graphics2D graphics2D = bufferedImage.createGraphics(); graphics2D.setColor(Color.GRAY);//将图像填充为浅灰色 graphics2D.fillRect(0, 0, width, height); graphics2D.setColor(Color.BLACK);//画边框 graphics2D.drawRect(0, 0, width - 1, height - 1); //随机产生16条灰色干扰线 graphics2D.setColor(Color.darkGray); //创建一个随机数生成器类，用于随机产生干扰线 Random random = new Random(); for (int i = 0; i \u003c 16; i++) { int x = random.nextInt(width); int y = random.nextInt(height); int x1 = random.nextInt(50); int y1 = random.nextInt(50); graphics2D.drawLine(x, y, x1, y1); } //计算字的位置坐标 int codeCount = 4;//字的个数 int fontHeight ;//字体高度 int codeX;//第一个字符的x坐标，因为后面的字符坐标依次递增，所以他们的x轴值是codeX+i的值 int codeY;//验证字符的y坐标，因为并排所以值一样 //width-4除去左右多余的位置，使验证码更加集中显示，减的越多越集中 //codeCount+1//等比分配显示的宽度，包括左右两边的空格 codeX = (width - 4) / (codeCount + 1);//第一个字母的起始位置 fontHeight = height - 10;//height-10高度中间区域显示验证码 codeY = height - 7; //创建字体，字体的大小应该根据图片的高度来定 Font font = new Font(\"Fixedsys\", Font.PLAIN, fontHeight); graphics2D.setFont(font); //随机产生codeCount数字的验证码 for (int i = 0; i \u003c codeCount; i++) { //每次随机拿一个字母，赋予随机的颜色 String strRand = String.valueOf(codeSequence[random.nextInt(charNum)]); int red = random.nextInt(255); int blue = random.nextInt(255); int green = random.nextInt(255); graphics2D.setColor(new Color(red, green, blue)); //把字放到图片上 graphics2D.drawString(strRand, (i + 1) * codeX, codeY); } ImageIO.write(bufferedImage, \"jpg\", new File(filePath)); } } ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:8:0","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"多进程和多线程 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:9:0","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"概念 多进程 当前的操作系统都是多任务OS 每个独立执行的任务就是一个进程 OS将时间划分为多个时间片（时间很短） 每个时间片内将CPU分配给某一个任务，时间片结束，CPU自动回收，再分配给另外任务。从外部看，所有任务都是同时在执行。 但是在CPU上，任务是按照串行依次运行（单核CPU ）。如果多核，多个进程任务可以并行。但是单个核上，多进程只能串行执行 多进程的优点 可以同时运行多个任务 程序因IO堵塞时，可以释放CPU，让CPU为其他程序服务 当系统有多个CPU时，可以为多个程序同时服务 我们的CPU不再提高频率，而是提高核数 多核和并行程序才是提高程序性能的唯一办法 多进程的缺点 太笨重，不好管理 太笨重，不好切换 多线程 一个程序可以包括多个子任务，可串/并行 每个子任务可以称为一个线程 如果一个子任务阻塞，程序可以将CPU调度另外一个子任务进行工作，这样CPU还是保留在本程序中，而不是被调度到别的程序（进程）去， 这样，提高本程序获得CPU时间和利用率 启动 start方法，会自动以新进程调用run方法 直接调用run方法，会编程串行执行 同一个线程，多次start会报错，只执行第一次start方法 多个线程启动，其启动的先后顺序是随机的 线程无需关闭，只要其run方法执行结束后，自动关闭 main函数（线程）可能早于新线程结束，整个程序并不终止 整个程序终止是等所有的线程都终止（包括main函数线程） ####多线程实现的对比 Thread占据了父类名额，不如Runnable方便 Thread类实现Runnable Runnable启动时需要Thread类的支持 Runnable更容易实现多线程中资源共享 结论：建议实现Runnable接口来完成多线程 规则 规则一： 1.调用run方法来启动run方法，将会是串行运行 2. 调用start方法，来启动run方法，将会是并行运行（多线程运行） 规则二： main线程可能早于子线程结束 main线程和子线程都结束了，整个程序才算终止 规则三： 1.实现Runnable的对象必须包装在Thread类里面，才可以启 不能直接对Runnable对象进行start方法 规则四： 一个线程对象不能多次start，多次start将报异常 多个线程对象都start后，哪一个先执行，完全由JVM/操作系统来主导，程序员无法指定 一： package JavaLearning_Advanced.thread.rules; /** * @Description: * 规则一： * 1.调用run方法来启动run方法，将会是串行运行 * 2. 调用start方法，来启动run方法，将会是并行运行（多线程运行） * * @author: Anhlaidh * @date: 2020/3/28 0028 22:59 */ public class first { public static void main(String[] args) throws InterruptedException { new TestThread0().run(); while (true) { System.out.println(\"main\"); Thread.sleep(10); } } } class TestThread0 extends Thread{ @Override public void run() { while (true) { System.out.println(\"testThread0\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } 二： package JavaLearning_Advanced.thread.rules; /** * @Description: * 规则二： * 1. main线程可能早于子线程结束 * 2. main线程和子线程都结束了，整个程序才算终止 * @author: Anhlaidh * @date: 2020/3/28 0028 23:06 */ public class second { public static void main(String[] args) throws InterruptedException { new TestThread1().start(); // while (true) { // System.out.println(\"main\"); // Thread.sleep(10); // } } } class TestThread1 extends Thread{ @Override public void run() { while (true) { System.out.println(\"testThread1\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } 三: package JavaLearning_Advanced.thread.rules; /** * @Description: * 规则三： * 1.实现Runnable的对象必须包装在Thread类里面，才可以启动 * 2. 不能直接对Runnable对象进行start方法 * @author: Anhlaidh * @date: 2020/3/28 0028 23:33 */ public class third { public static void main(String[] args) throws InterruptedException { // new TestThread2().start(); //runnable对象必须放在一个Thread类中才能运行 TestThread2 tt = new TestThread2(); Thread thread = new Thread(tt); thread.start(); while (true) { System.out.println(\"main\"); Thread.sleep(1000); // } } } } class TestThread2 implements Runnable { @Override public void run() { while (true) { System.out.println(Thread.currentThread().getName()); //输出当前线程名 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } 四： package JavaLearning_Advanced.thread.rules; /** * @Description: * 规则四： * 1. 一个线程对象不能多次start，多次start将报异常 * 2. 多个线程对象都start后，哪一个先执行，完全由JVM/操作系统来主导，程序员无法指定 * @author: Anhlaidh * @date: 2020/3/28 0028 23:39 */ public class Fourth { public static void main(String[] args) { TestThread4 t1 = new TestThread4(); t1.start(); // t1.start(); TestThread4 t2 = new TestThread4(); t2.start(); } } class TestThread4 extends Thread { @Override public void run() { while (true) { System.out.println(Thread.currentThread().getName()+\"is running\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } 多进程和多线程的对比 线程共享数据 线程通讯更高效 线程更轻量级，更容易切换 多个线程更容易管理 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:9:1","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"多线程信息共享 线程类 通过继承Thread或实现Runnable 通过start方法，调用run方法，run方法工作 线程run结束后，线程退出 粗粒度：子线程与子线程之间、和main线程之间缺乏交流 细粒度：线程之间有信息交流通讯 通过共享变量达到信息共享 Jdk原生库不支持发送消息 通过共享变量在多个线程中共享消息 static变量 同一个Runnable类的成员变量 test1:继承thread，static修饰的变量可以共享，但是会造成数据重复 package JavaLearning_Advanced.thread.message; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 20:23 */ public class ThreadDemo0 { public static void main(String[] args) { new TestThread0().start(); new TestThread0().start(); new TestThread0().start(); new TestThread0().start(); } private static class TestThread0 extends Thread { // private int tickets = 100; 每个线程卖100张，没有共享 private static int tickets = 100; //static变量是共享的，所有的线程共享 @Override public void run() { while (tickets\u003e0) { System.out.println(Thread.currentThread().getName() + \" is selling tickets\" + tickets); tickets = tickets - 1; } } } } 多线程信息共享问题 工作缓存副本 关键步骤缺乏加锁限制 i++，并非原子性操作 读取主存i（正本）到工作缓存（副本）中 每个CPU执行（副本）i+1操作 CPU将结果写入到缓存（副本）中 数据从工作缓存（副本）刷到主存（正本）中 变量副本问题的解决办法 采用volatile关键字修饰变量 保证不同线程对共享变量操作时的可见性 package JavaLearning_Advanced.thread.message; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 20:55 */ public class ThreadDemo2 { public static void main(String[] args) throws InterruptedException { TestTread3 testTread3 = new TestTread3(); testTread3.start(); Thread.sleep(1000); testTread3.flag = false; System.out.println(\"main thread is exiting\"); } private static class TestTread3 extends Thread { // boolean flag = true;//子线程不会停止 volatile boolean flag = true;//用volatile修饰的变量可以及时在各线程里面通知 @Override public void run() { int i = 0; while (flag) { i++; } System.out.println(\"test thread is exiting\"); } } } 关键步骤加锁限制 互斥：某一个线程运行一个代码段（关键区），其他线程不能同时运行这个代码段 同步：多个线程的运行，必须按照某一种规定的先后顺序来运行 互斥是同步的一种特例 互斥的关键字是synchronized synchronized代码块/函数，只能一个线程进入 synchronized能加大性能负担，但是使用简便 package JavaLearning_Advanced.thread.message; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 21:16 */ public class ThreadDemo3 { public static void main(String[] args) { TestThread3 testThread3 = new TestThread3(); new Thread(testThread3).start(); new Thread(testThread3).start(); new Thread(testThread3).start(); new Thread(testThread3).start(); } private static class TestThread3 implements Runnable { private volatile int tickets = 100; @Override public void run() { while (tickets\u003e0) { sale(); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } private synchronized void sale() { System.out.println(Thread.currentThread().getName() + \" sale \" + tickets--); } } } ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:9:2","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"多线程管理 线程状态 NEW 刚创建（new） RUNNABLE就绪态（start） RUNNING运行中（run） BLOCK阻塞（sleep） TERMINATED 结束 Thread的部分API已经废弃 暂停和恢复：suspend/resume 消亡：stop/destroy 线程阻塞/和唤醒 sleep，时间一到，自己就会醒来 wait/notify/notifyAll，等待，需要别人来唤醒 join，等待另一个线程结束 interrupt，向另外一个线程发送中断信号，该线程收到信号，会触发 Interrupted Exception（可接触阻塞），并进入下一步处理 线程类 主动interrupt 被动interrupt 多线程死锁 每个线程相互持有别人需要的锁（哲学家吃面问题） 预防死锁，对资源进行等级排序 package JavaLearning_Advanced.thread.Interrupt; import java.util.concurrent.TimeUnit; /** * @Description: * @author: Anhlaidh * @date: 2020/4/7 0007 22:05 */ public class DeadLock { public static Integer r1 = 1; public static Integer r2 = 2; public static void main(String[] args) { Thread1 t1 = new Thread1(); t1.start(); Thread2 t2 = new Thread2(); t2.start(); } } class Thread1 extends Thread { @Override public void run() { //先要r1再要r2 synchronized (DeadLock.r1) { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (DeadLock.r2) { System.out.println(\"Thread1 is running\"); } } } } class Thread2 extends Thread { @Override public void run() { //先要r2再要r1 synchronized (DeadLock.r2) { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (DeadLock.r1) { System.out.println(\"Thread2 is running\"); } } } } 守护（后台）线程 普通线程的结束，是run方法运行结束 守护线程的结束，是run方法运行结束，或main函数结束 守护线程永远不要访问资源，如文件或数据库等 package JavaLearning_Advanced.thread.Interrupt; /** * @Description: * @author: Anhlaidh * @date: 2020/4/7 0007 22:19 */ public class protect { public static void main(String[] args) throws InterruptedException { Thread3 t = new Thread3(); t.setDaemon(true); t.start(); Thread.sleep(2000); System.out.println(\"main thread is exiting\"); } } class Thread3 extends Thread { @Override public void run() { while (true) { try { Thread.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"running\"); } } } 线程查看工具jvisualvm ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:9:3","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"并发框架 业务：任务多，数据量大 串行 并行 串行编程简单，并行编程困难 单个计算核频率下降，计算核数增多，整体性能变高 并行困难（任务分配和执行过程高度耦合） 如何控制粒度，切割任务 如何分配任务给线程，监督线程执行过程 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:9:4","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"并行计算 并行模式 主从模式(Master-Slave) Worker模式(Worker-Worker) Java并发编程 Thread/Runnable/Thread组管理 Executor(重点) Fork-Join框架 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:9:5","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"线程组管理 线程组ThreadGroup 线程的集合 树形结构,大线程可以包括小线程组 可以通过enumerate方法遍历组内的线程,执行操作 能够有效管理多个线程,但是管理效率低 任务分配和执行过程高度耦合 重复创建线程,关闭线程操作,无法重用线程 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:9:6","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"Executor* 从jdk5开始提供Executor FrameWork 分离任务的创建和执行者的创建 线程重复利用(new线程代价很大) 理解共享线程池的概念 预设好的多个Thread,可弹性增加 多次执行很多很小的任务 任务创建和执行过程解耦 程序员无需关心线程池执行任务过程 Main: package JavaLearning_Advanced.thread.Executor.example2; import java.util.ArrayList; import java.util.List; import java.util.concurrent.ExecutionException; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.ThreadPoolExecutor; /** * @Description: * @author: Anhlaidh * @date: 2020-04-08 22:15 */ public class SumTest { public static void main(String[] args) { //执行线程池 ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(8); List\u003cFuture\u003cInteger\u003e\u003e resultList = new ArrayList\u003c\u003e(); //统计1-1000总和,分成10个任务计算,提交任务 for (int i = 0; i \u003c 10; i++) { SumTask calculator = new SumTask(i*100+1,(i+1)*100); Future\u003cInteger\u003e result = executor.submit(calculator); resultList.add(result); } //每隔50毫秒,轮询等待10个任务结束 do { System.out.printf(\"Main:已经完成了多少个任务:%d\\n\", executor.getCompletedTaskCount()); for (int i = 0; i \u003c resultList.size(); i++) { Future\u003cInteger\u003e result = resultList.get(i); System.out.printf(\"Main Task %d:%s\\n\", i, result.isDone()); } try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } } while (executor.getCompletedTaskCount() \u003c resultList.size()); //所有任务都已经结束,综合计算结果 int total = 0; for (int i = 0; i \u003c resultList.size(); i++) { Future\u003cInteger\u003e result = resultList.get(i); Integer sum = null; try { sum = result.get(); total = total + sum; } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } System.out.println(\"1-1000的总和\" + total); } } SumTask: package JavaLearning_Advanced.thread.Executor.example2; import java.util.Random; import java.util.concurrent.Callable; /** * @Description: * @author: Anhlaidh * @date: 2020-04-08 22:17 */ public class SumTask implements Callable { private int startNumber; private int endNumber; public SumTask(int startNumber, int endNumber) { this.startNumber = startNumber; this.endNumber = endNumber; } @Override public Integer call() throws Exception { int sum = 0; for (int i = startNumber; i \u003c= endNumber; i++) { sum = sum + i; } Thread.sleep(new Random().nextInt(1000)); System.out.printf(\"%s:%d\", Thread.currentThread().getName(), sum); return sum; } } ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:9:7","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"Fork-Join 关键类 ForkJoinPool 任务池 RecursiveAction RecursiveTask Main: package JavaLearning_Advanced.thread.Fork_Join; import java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; /** * @Description: * @author: Anhlaidh * @date: 2020-04-09 13:37 */ public class SumTest { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建执行线程池 ForkJoinPool pool = new ForkJoinPool(8); //创建任务 SumTask task = new SumTask(1,1000000); //提交任务 ForkJoinTask\u003cLong\u003e result = pool.submit(task); //等待结果 do { System.out.printf(\"Main:Thread Count:%d\\n\", pool.getActiveThreadCount()); System.out.printf(\"Main:Parallelism:%d\\n\", pool.getParallelism()); try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } } while (!task.isDone()); //输出结果 System.out.println(result.get().toString()); } } SumTask package JavaLearning_Advanced.thread.Fork_Join; import java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; /** * @Description: * @author: Anhlaidh * @date: 2020-04-09 13:37 */ public class SumTest { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建执行线程池 ForkJoinPool pool = new ForkJoinPool(8); //创建任务 SumTask task = new SumTask(1,1000000); //提交任务 ForkJoinTask\u003cLong\u003e result = pool.submit(task); //等待结果 do { System.out.printf(\"Main:Thread Count:%d\\n\", pool.getActiveThreadCount()); System.out.printf(\"Main:Parallelism:%d\\n\", pool.getParallelism()); try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } } while (!task.isDone()); //输出结果 System.out.println(result.get().toString()); } } 主要类 ExecutorService,ThreadPoolExecutor,Future Executors.newCachedThreadPool/newFixedThreadPool创建线程池 ExecutorService线程池服务 Callable 具体的逻辑对象(线程类) Future返回结果 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:9:8","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"并发数据结构 阻塞式集合:当集合为空或者满时,等待 非阻塞式集合:当集合为空或者满时,不等待,返回null或异常 -List - Vector 同步安全,写多读少 - ArrayList 不安全 - Collections.synchronizedList(List list) 基于synchronized,效率差 - CopyOnWriteArrayList 读多写少,基于复制机制,非阻塞 Set HashSet不安全 Collections.synchronizedSet(Set set)基于synchronized,效率差 CopyOnWriteArraySet (基于CopyOnWriteArrayList实现),读多写少,非阻塞 Map Hashtable 同步安全,写多读少 HashMap 不安全 Collections.synchronizedMap(Map map)基于synchronized,效率差 ConcurrentHashMap,读多写少,非阻塞 Queue\u0026Deque ConcurrentLinkedQueue非阻塞 ArrayBlockingQueue/LinkedBlockingQueue阻塞 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:9:9","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"并发协作与控制 Lock 买奶茶,读写锁,互斥锁 Lock也可以实现同步的效果 实现更复杂的临界区结构 tryLock方法可以预判锁是否空闲 允许分离读写的操作,多个读,一个写 性能更好 ReentrantLock 类,可重入的互斥锁 ReentrantReadWriteLock类,可重入的读写锁 lock和unlock函数 package notes.Java.JavaLearning_Advanced.thread.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.concurrent.locks.ReentrantReadWriteLock; /** * @Description: * @author: Anhlaidh * @date: 2020-05-07 16:41 */ public class LockExample { private static final ReentrantLock queueLock = new ReentrantLock();//可重入锁 private static final ReentrantReadWriteLock orderLock = new ReentrantReadWriteLock();//可读写锁 /** * 有家奶茶店,点单时需要排队 * 假设想买奶茶的人如果看到需要排队就等等 * 假设奶茶店又老板和多名员工,记单方式比较原始,只有一个订单本 * 老板负责写新订单,员工不断查看订单本得到信息来制作奶茶,在老板写订单时员工不可以看订单本 * 多个员工可同时看订单本,但此时老板不可写入订单本 * @param args args */ public static void main(String[] args) { // byMilkTea(); handleOrder(); } private static void byMilkTea() { LockExample lockExample = new LockExample(); int CUSTOMER_CNT = 10; Thread[] customers = new Thread[CUSTOMER_CNT]; for (int i = 0; i \u003c CUSTOMER_CNT; i++) { customers[i] = new Thread(new Runnable() { @Override public void run() { try { long walkingTime = (long) (Math.random() * 1000); Thread.sleep(walkingTime); lockExample.tryToBuyMilkTea(); } catch (InterruptedException e) { System.out.println(e.getMessage()); } } }); customers[i].start(); } } private void tryToBuyMilkTea() throws InterruptedException { boolean flag = true; while (flag) { if (queueLock.tryLock()) { // queueLock.lock(); long thinkingTime = (long) (Math.random() * 500); Thread.sleep(thinkingTime); System.out.println(Thread.currentThread().getName() + \":来一杯奶茶,不要珍珠\"); flag = false; queueLock.unlock(); } else { System.out.println(Thread.currentThread().getName()+\":再等等\"); } if (flag) { Thread.sleep(1000); } } } private static void handleOrder() { LockExample lockExample = new LockExample(); Thread boss = new Thread(new Runnable() { @Override public void run() { while (true) { try { lockExample.addOrder(); long waitingTime = (long) (Math.random() * 1000); Thread.sleep(waitingTime); } catch (InterruptedException e) { System.out.println(e.getMessage()); } } } }); boss.start(); int WORKER_CNT = 3; Thread[] workers = new Thread[WORKER_CNT]; for (int i = 0; i \u003c WORKER_CNT; i++) { workers[i] = new Thread(new Runnable() { @Override public void run() { while (true) { try { lockExample.viewOrder(); long workingTime = (long) (Math.random() * 5000); Thread.sleep(workingTime); } catch (InterruptedException e) { System.out.println(e.getMessage()); } } } }); workers[i].start(); } } private void viewOrder() throws InterruptedException { orderLock.readLock().lock(); long readingTime = (long) (Math.random() * 500); Thread.sleep(readingTime); System.out.println(Thread.currentThread().getName()+\":查看订单\"); orderLock.readLock().unlock(); } private void addOrder() throws InterruptedException { orderLock.writeLock().lock(); long writingTime = (long) (Math.random() * 1000); Thread.sleep(writingTime); System.out.println(\"老板新加一笔订单\"); orderLock.writeLock().unlock(); } } Semaphore 抢车位,车位满了不可停车,其他等着 信号量:由1965年Dijkstra提出 信号量:本质上是一个计数器 计数器大于0,可以使用,等于0不能使用 可以设置多个并发量,例如限制10个访问 Semaphore acquire获取 release释放 比lock更进一步,可以控制多个同时访问关键区 package notes.Java.JavaLearning_Advanced.thread.Semaphore; import java.util.concurrent.Semaphore; /** * @Description: * @author: Anhlaidh * @date: 2020-05-07 17:48 */ public class SemaphoreExample { private final Semaphore placeSemaphore = new Semaphore(5); public boolean parking() { if (placeSemaphore.tryAcquire()) { System.out.println(Thread.currentThread().getName() + \"停车成功\"); return true; } else { System.out.println(Thread.currentThread().getName() + \"没有空位\"); return false; } } public void leaving() { placeSemaphore.release(); System.out.println(Thread.currentThread().getName()+\":开走\"); } /** * 一个车库,五个车位,十辆车需要停放,每次停放时,申请信号量 * @param args args * @throws InterruptedException exception */ public static void main(String[] args) throws InterruptedException { int tryToParkCnt = 10; SemaphoreExample semaphoreExample = new Semaphor","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:9:10","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"定时任务 简单定时机制 设置计划任务,也就是在指定的时间开始执行某一个任务 TimerTask封装任务 Timer类 定时器 Timer package notes.Java.JavaLearning_Advanced.thread.Timer; import java.util.Calendar; import java.util.Date; import java.util.Timer; import java.util.TimerTask; /** * @Description: * @author: Anhlaidh * @date: 2020-05-10 17:42 */ public class TimerTest { public static void main(String[] args) throws InterruptedException { MyTask myTask = new MyTask(); Timer timer = new Timer(); System.out.println(\"当前时间:\" + new Date().toLocaleString()); //当前时间一秒后,每两秒执行一次 timer.schedule(myTask,1000,2000); Thread.sleep(10000); myTask.cancel();//取消当前任务 System.out.println(\"==============\"); Calendar now = Calendar.getInstance(); now.set(Calendar.SECOND, now.get(Calendar.SECOND) + 3); Date runDate = now.getTime(); MyTask2 myTask2 = new MyTask2(); timer.scheduleAtFixedRate(myTask2,runDate,3000); } private static class MyTask extends TimerTask { @Override public void run() { System.out.println(\"运行了!时间为:\"+new Date()); } } private static class MyTask2 extends TimerTask{ @Override public void run() { System.out.println(\"运行了!时间为:\"+new Date()); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } } } } Executor+定时器机制 ScheduledExecutorService 定时任务 周期任务 Quartz Quartz是一个较为完善的任务调度框架 解决程序中Timer零散管理的问题 功能更加强大 Timer执行周期任务,如果中间有一次有一场,整个任务终止执行 Quartz执行周期任务,如果中间某一次有异常,不影响下次任务执行 ​ ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:9:11","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"Java网络编程 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:10:0","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"网络基础知识 网络是当前信息技术的第一推动力 每个计算设备上都有若干个网卡 每个网卡上有（全球唯一）单独的硬件地址，MAC地址 ip地址 IPV4 192.169.0.1每段0-255 IPV6 128bit长，8段，每段4个16进制数 ipconfig ifconfig port:端口 0~65535 0~1023OS已经占用了，80是web，23是telnet 1024~65535，一般程序可使用（谨防冲突） 两台机器通讯就是在IP+port上进行的 netstat -an 保留ip：127.0.0.1 本机 公网（万维网/互联网）和内网（局域网） 网络上分层的 最外层的是外网/互联网 底下每层都是内网 ip地址可以在每个层次的网重用 tracert 看当前及其和目标机器的访问中继 通讯协议TCP UDP TCP(Transmission Control Protocol) 传输控制协议，面向连接的协议 两台机器的可靠无差错的数据传输 双向字节流传递 UDP(User Datagram Protocol) –\u003eQQ(多次UDP模仿TCP) 用户数据报协议，面向无连接协议 不保证可靠的数据传输 速度快，也可以在较差的网络下使用 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:10:1","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"UDP 计算机通讯：数据从一个IP的port出发（发送方），运输到另外一个IP的port（接收方） UDP：无连接无状态的通讯协议 发送方发送消息，如果接收方刚好在目的地，则可以接受，如果不在 那这个消息就丢失了 发送方也无法得知是否发送成功 UDP的好处就是简单节省，经济 实例 DatagramSocket:通讯的数据管道 send和receive方法 （可选，多网卡）绑定一个IP和Port DatagramPacket 集装箱：封装数据 地址标签：目的地IP+Port Receive: package JavaLearning_Advanced.UDP; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; /** * @Description: receive * @author: Anhlaidh * @date: 2020/3/29 0029 0:23 */ public class UdpRecv { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(3000); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf,buf.length); System.out.println(\"UdpRecv：等待信息\"); socket.receive(packet); System.out.println(\"UdpRecv:已接受信息\"); String strRecv = new String(packet.getData(), 0, packet.getLength()) + \"from\" + packet.getAddress().getHostAddress() + \":\" + packet.getPort(); System.out.println(strRecv); String str = \"nice to meet you!!\"; DatagramPacket packet1 = new DatagramPacket(str.getBytes(), str.length(), packet.getAddress(), packet.getPort()); System.out.println(\"UdpRecv:即将发送信息！\"); socket.send(packet1); System.out.println(\"UdpRecv:已发送\"); } } send: package JavaLearning_Advanced.UDP; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; /** * @Description: send * @author: Anhlaidh * @date: 2020/3/29 0029 0:24 */ public class UdpSend { public static void main(String[] args) throws Exception{ DatagramSocket socket = new DatagramSocket(); String str = \"hi ,im a mini robot\"; DatagramPacket packet = new DatagramPacket(str.getBytes(), str.length(), InetAddress.getByName(\"127.0.0.1\"), 3000); System.out.println(\"UdpSend:我要发送信息了\"); socket.send(packet); System.out.println(\"UdpSend: 发送完毕\"); Thread.sleep(1000); byte[] buf = new byte[1024]; DatagramPacket packet1 = new DatagramPacket(buf, 1024); System.out.println(\"UdpSend：我在等待信息\"); socket.receive(packet1); System.out.println(\"UdpSend：已收到信息\"); String str2 = new String(packet1.getData(), 0, packet1.getLength())+\"from\"+packet1.getAddress().getHostAddress() +\":\"+packet1.getPort(); System.out.println(str2); } } ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:10:2","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"TCP TCP协议：有链接、保证可靠的无误差通讯 服务器：创建一个ServerSocket，等待连接 客户机：创建一个Socket，连接到服务器 服务器：ServerSocket接收到连接，创建一个Socket和客户的Socket建立专线连接，后续服务器和客户机的对话 （这一对Socket）会在一个单独的线程（服务器端）上运行 服务器的ServerSocket继续等待连接，返回 i. 软件服务器有两要求： 它能够实现一定的功能 它必须在一个公开地址上对外提供服务 ServerSocket：服务码头 需要绑定Port 如果有多块网卡，需要绑定一个IP地址 Socket：运输通道 客户端需要绑定服务器的地址和Port 客户端往Socket输入流写入数据，送到服务端 客户端从Socket输出流取服务端过来的数据 服务器反之亦然 过程： 服务端等待响应时，处于阻塞状态 服务端可以同时响应多个客户端 服务端每接受一个客户端，就启动一个独立的线程与其对应 客户端或者服务端都可以选择关闭这条Socket通道 实例 服务端先启动，且一直保留 客户端后启动，可以先退出 Server: package JavaLearning_Advanced.TCP; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 13:16 */ public class TCPServer2 { public static void main(String[] args) { try { ServerSocket serverSocket = new ServerSocket(8001); while (true) { Socket socket = serverSocket.accept(); System.out.println(\"来了一个client\"); new Thread(new Worker(socket)).start(); } } catch (Exception e) { e.printStackTrace(); } } private static class Worker implements Runnable{ private Socket socket; public Worker(Socket socket) { this.socket = socket; } @Override public void run() { try { System.out.println(\"服务人员已启动\"); InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); DataOutputStream dos = new DataOutputStream(outputStream); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); while (true) { String strWord = bufferedReader.readLine(); System.out.println(\"client said:\" + strWord + \":\" + strWord.length()); if (strWord.equalsIgnoreCase(\"quit\")) { break; } String strEcho = strWord + \"666\"; System.out.println(\"server said:\" + strWord + \"---------\u003e\" + strEcho); dos.writeBytes(strWord + \"---------\u003e\" +strEcho+ System.getProperty(\"line.separator\")); } bufferedReader.close(); dos.close(); } catch (Exception e) { e.printStackTrace(); } } } } Client: package JavaLearning_Advanced.TCP; import java.io.*; import java.net.InetAddress; import java.net.Socket; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 11:47 */ public class TcpClient { public static void main(String[] args) { try { Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 8001); // 同一个通道，服务端输出流就是客户端的输入流，服务端的输入流，就是客户端的输出流 InputStream inputStream = socket.getInputStream();//开启通道的输入流 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); OutputStream outputStream = socket.getOutputStream();//开启通道的输出流 DataOutputStream dataOutputStream = new DataOutputStream(outputStream); BufferedReader brKey = new BufferedReader(new InputStreamReader(System.in)); while (true) { String strWord = brKey.readLine(); if (strWord.equalsIgnoreCase(\"quit\")) { break; } else { System.out.println(\"i want to sent \"+strWord); // outputStream.write(strWord.getBytes(), 0, strWord.length());//可以这么写 dataOutputStream.writeBytes(strWord+System.getProperty(\"line.separator\")); System.out.println(\"server said\"+bufferedReader.readLine()); } } dataOutputStream.close(); bufferedReader.close(); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:10:3","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"HTTP 在浏览器输入URL地址 浏览器将连接到远程服务器（IP=Port(80)） 请求下载一个HTML文件下来，放到本地临时文件夹中 在浏览器显示出来 实例 URLConnection 获取资源的连接器 根据URL的openConnection()方法获得URLConnection connect方法，建立和资源的联系通道 getInputStream方法，获取资源的内容 get: package JavaLearning_Advanced.HTTP; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.URL; import java.net.URLConnection; import java.util.List; import java.util.Map; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 14:14 */ public class URLConnectionGet { public static void main(String[] args) { try { String urlName = \"http://www.baidu.com\"; URL url = new URL(urlName); URLConnection connection = url.openConnection(); connection.connect(); //打印Http的头部信息 Map\u003cString, List\u003cString\u003e\u003e headers = connection.getHeaderFields(); for (Map.Entry\u003cString, List\u003cString\u003e\u003e entry : headers.entrySet()) { String key = entry.getKey(); for (String value : entry.getValue()) { System.out.println(key + \":\" + value); } } //输出将要收到的内容属性信息 System.out.println(\"-------------------\"); System.out.println(\"getContentType\" + connection.getContentType()); System.out.println(\"getContentLength\" + connection.getContentLength()); System.out.println(\"getContentEncoding\" + connection.getContentEncoding()); System.out.println(\"getDate\" + connection.getDate()); System.out.println(\"getExpiration\" + connection.getExpiration()); System.out.println(\"getLastModified\" + connection.getLastModified()); System.out.println(\"-------------------\"); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream(),\"UTF-8\")); //输出收到的内容 String line = \"\"; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } } } Post: package JavaLearning_Advanced.HTTP; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.net.*; import java.util.HashMap; import java.util.Map; import java.util.Scanner; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 14:42 */ public class URLConnectionPost { public static void main(String[] args) throws IOException { String url = \"https://www.usps.com/go/ZipLookupAction.action\"; Object userAgent = \"Httpie/0.9.2\"; Object redirects = \"1\"; CookieHandler.setDefault(new CookieManager(null, CookiePolicy.ACCEPT_ALL)); Map\u003cString, String\u003e params = new HashMap\u003cString, String\u003e(); params.put(\"tAddress\", \"1 Market Street\"); params.put(\"tCity\", \"San Francisco\"); params.put(\"sState\", \"CA\"); String result = doPost(new URL(url), params, userAgent == null ? null : userAgent.toString(), redirects == null ? -1 : Integer.parseInt(redirects.toString())); System.out.println(result); } private static String doPost(URL url, Map\u003cString, String\u003e nameValueParis, String userAgent, int redirects) throws IOException { HttpURLConnection connection = (HttpURLConnection) url.openConnection(); if (userAgent != null) { connection.setRequestProperty(\"User-Agent\", userAgent); } if (redirects \u003e= 0) { connection.setInstanceFollowRedirects(false); connection.setDoOutput(true); } //输出请求的参数 try (PrintWriter out = new PrintWriter(connection.getOutputStream())) { boolean first = true; for (Map.Entry\u003cString, String\u003e pair : nameValueParis.entrySet()) { //参数必须这样拼接a=1\u0026b=2\u0026c=3 if (first) { first = false; } else { out.println('\u0026'); } String name = pair.getKey(); String value = pair.getValue(); out.print(name); out.print('='); out.print(URLEncoder.encode(value, \"UTF-8\")); } String encoding = connection.getContentEncoding(); if (encoding == null) { encoding = \"UTF-8\"; } if (redirects \u003e 0) { int responseCode = connection.getResponseCode(); System.out.println(\"responseCode:\" + responseCode); if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_SEE_OTHER) { String location = connection.getHeaderField(\"Location\"); if (location !","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:10:4","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"JDK HttpClient (JDK9新增，JDK10更新，JDK11正式发布) java.net.http包 取代URLConnection 支持HTTP/1.1和HTTP/2 实现大部分HTTP方法 主要类 HttpClient HttpRequest HttpResponse Get: package JavaLearning_Advanced.HTTP.HttpClient; import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 15:38 */ public class JDKHttpClientGet { public static void main(String[] args) { doGet(); } private static void doGet() { try { HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder(URI.create(\"http://www.baidu.com\")).build(); HttpResponse response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); } catch (Exception e) { e.printStackTrace(); } } } Post: package JavaLearning_Advanced.HTTP.HttpClient; import java.net.URI; import java.net.URLEncoder; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 15:43 */ public class JDKHttpClientPost { public static void main(String[] args) { doPost(); } private static void doPost() { try { HttpClient client = HttpClient.newBuilder().build(); HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(\"https://zh-tools.usps.com/zip-code-lookup.htm?byaddress\")) .header(\"User-Agent\", \"HTTPie/0.9.2\") .header(\"Content-Type\", \"application/x-www-form-urlencoded;charset=utf-8\") .POST(HttpRequest.BodyPublishers.ofString( \"tAdress=\" + URLEncoder.encode(\"1 Market Street\", \"UTF-8\") + \"tCity=\"+ URLEncoder.encode(\"San Francisco\", \"UTF-8\") + \"sState=\"+ \"CA\") ).build(); HttpResponse response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.statusCode()); System.out.println(response.headers()); System.out.println(response.body().toString()); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:10:5","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"HttpComponent Get: package JavaLearning_Advanced.HTTP.HttpComponet; import org.apache.http.HttpResponse; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.methods.HttpGet; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 16:53 */ public class HttpComponentsGet { public static void main(String[] args) { CloseableHttpClient httpClient = HttpClients.createDefault(); RequestConfig requestConfig = RequestConfig.custom() .setConnectionRequestTimeout(5000)//设置超时时间 .setConnectionRequestTimeout(5000)//设置请求超时时间 .setSocketTimeout(5000) .setRedirectsEnabled(true)//默认允许自动重定向 .build(); HttpGet httpGet = new HttpGet(\"http://www.baidu.com\"); httpGet.setConfig(requestConfig); String strResult = \"\"; try { HttpResponse httpResponse = httpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() == 200) { strResult = EntityUtils.toString(httpResponse.getEntity(),\"UTF-8\");//获得返回结果 System.out.println(strResult); } } catch (Exception e) { e.printStackTrace(); } } } Post; package JavaLearning_Advanced.HTTP.HttpComponet; import org.apache.http.HttpResponse; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.HttpPost; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; import org.apache.http.impl.client.LaxRedirectStrategy; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.util.ArrayList; import java.util.List; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 17:03 */ public class HttpComponentsPost { public static void main(String[] args) throws UnsupportedEncodingException { //获取可关闭的httpClient //CloseableHttpClient CloseableHttpClient httpClient = HttpClientBuilder.create().setRedirectStrategy(new LaxRedirectStrategy()).build(); //配置超时时间 RequestConfig requestConfig = RequestConfig.custom() .setSocketTimeout(10000) .setConnectTimeout(10000) .setConnectionRequestTimeout(10000) .setRedirectsEnabled(false).build(); HttpPost httpPost = new HttpPost(\"https://zh-tools.usps.com/zip-code-lookup.htm?byaddress\"); //配置post参数 List\u003cBasicNameValuePair\u003e list = new ArrayList\u003c\u003e(); list.add(new BasicNameValuePair(\"tAdress\", URLEncoder.encode(\"1 Market Street\", \"UTF-8\")));//请求参数 list.add(new BasicNameValuePair(\"tCity\", URLEncoder.encode(\"San Francisco\", \"UTF-8\")));//请求参数 list.add(new BasicNameValuePair(\"sState\", \"CA\"));//请求参数 try { UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list, \"UTF-8\"); // 设置post请求参数 httpPost.setEntity(entity); httpPost.setHeader(\"User-Agent\", \"HTTPie/0.9.2\"); HttpResponse httpResponse = httpClient.execute(httpPost); String result = \"\"; if (httpResponse != null) { int statusCode = httpResponse.getStatusLine().getStatusCode(); System.out.println(statusCode); if (statusCode == 200) { result = EntityUtils.toString(httpResponse.getEntity()); } else { result = \"ERROR Response\" + httpResponse.getStatusLine().toString(); } } else { } System.out.println(result); } catch (Exception e) { e.printStackTrace(); }finally { try { if (httpClient != null) { httpClient.close(); } } catch (Exception e) { e.printStackTrace(); } } } } ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:10:6","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"Java调用其他语言 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:11:0","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":["笔记"],"content":"Python 解释性脚本语言 目前版本3 Jython 将Python源码编译成JVM字节码,由JVM执行对应的字节码,可以很好的与JVM继承 不是Java与Python的连接器 ","date":"2021-06-08","objectID":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/:11:1","tags":["java","junit","网络","多线程"],"title":"Anhlaidh的java笔记1","uri":"/posts/anhlaidh%E7%9A%84java%E7%AC%94%E8%AE%B01/"},{"categories":null,"content":"本文用于演示本站的对hugo写作功能的拓展以及实现 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:0:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"Mermaid 图 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:1:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"地图 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:2:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"youtube 视频 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:3:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"哔哩哔哩视频 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:4:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"网易云音乐 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:5:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"单曲： ","date":"2021-06-05","objectID":"/posts/markdown-extend/:5:1","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"歌单： ","date":"2021-06-05","objectID":"/posts/markdown-extend/:5:2","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"Latex 行内样式：$x=2$ 代码块： $$ f(x)=\\int_{-\\infty}^\\infty\\widehat f\\xi,e^{2\\pi i\\xi x},d\\xi $$ ","date":"2021-06-05","objectID":"/posts/markdown-extend/:6:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"打字段落 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:7:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"PlantUml \rDiagram\r ","date":"2021-06-05","objectID":"/posts/markdown-extend/:8:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"追番 ","date":"2021-06-05","objectID":"/posts/markdown-extend/:9:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"TODO PlantUml plantuml/plantuml-server: PlantUML Online Server (github.com) 通过JavaScript调用同步实时工作演示 (plantuml.com) ","date":"2021-06-05","objectID":"/posts/markdown-extend/:10:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":null,"content":"参考 HEXO博客引用B站视频并自动适配 [拓展hugo的markdown_流程图mermaid Hugo博客LaTeX渲染) ","date":"2021-06-05","objectID":"/posts/markdown-extend/:11:0","tags":null,"title":"Hugo Markdown 功能拓展","uri":"/posts/markdown-extend/"},{"categories":["日志"],"content":"2018年的夏天，我坚持了仅仅两个月的博客，因为服务器到期关停了。当初的我还设定了一天一篇博客的“伟大”目标。然而直到博客关停的时候，仓库里还留着10多篇没有完结的草稿。在过去的两年时间里，我时常想把这个博客重新办起来，最终也因为各种原因一直也没有付诸于实践。 最近我有了一点宽裕的时间，为了督促自己学习，我决定复活我的博客。 幸运的是，虽然博客关停了，但是之前的文章和草稿还存在Github的仓库中。 为了更快的让博客上线，我决定使用Hugo来构建博客，可以很好的兼容之前用hexo搭建的博客锁写的文章。由于Hugo是生成的静态站点文件，所以我选择了Github Pages进行部署，这样可以大幅度减少维护服务器的时间，也方便进行自动化部署。但是由于某些原因，Github在大陆地区的大部分位置都访问缓慢，用我宿舍所使用的电信宽带，甚至直接无法访问。为改善这一问题，我使用了cloudflare和百度云加速对站点进行加速。 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:0:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"安装Hugo Hugo是一个静态网站生成框架，其官方网站号称是 “The world’s fastest framework for building websites” Hugo是使用Go语言实现的,相比使用javascript的Hexo，生成网站的速度确实要快很多，一次执行只需要几百毫秒。Hugo生成的网站是纯静态的，无需任何后端，部署和二次开发都很简单。使用Hugo写博客的工作流程很简单：首先使用markdown进行写作，在本地使用Hugo生成静态的网页，然后上传到任何可以访问的web服务器上就完成了，所以现在开始第一步：在本地安装Hugo。 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:1:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"使用二进制包进行安装 根据官方提供的快速指南，最直接的安装方式，就是下载二进制包，在Hugo的Github主页中，可以下载到各种平台(Windows,Linux,Mac )的二进制包，只要解压并在操作系统的环境变量中添加进去，就可以直接使用，使用hugo version指令可以查看hugo的安装情况 PS C:\\Users\\19796\u003e hugo version hugo v0.83.1-5AFE0A57+extended windows/amd64 BuildDate=2021-05-02T14:38:05Z VendorInfo=gohugoio ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:1:1","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"使用包管理进行安装 不过显然，使用包管理工具才是更加优雅便捷的安装方式，下面提供三种系统的安装方式 Mac Mac的用户直接使用Homebrew或者MacPorts就可以快速进行安装： brew install Hugo # 或者 port install Hugo Linux Linux用户也可以直接使用Homebrew进行安装，另外部分发行版，如Ubuntu中的软件源，提供hugo 的包，但是版本较老，不推荐使用，并且由于大多数现代主题使用了scss等技术，可能需要安装hugo-extend版本，镜像源中亦没有提供，所以推荐Linux用户使用二进制包或者Homebrew进行安装。 Windows 笔者使用的系统是Windows10，在Windows上也有一些流行的包管理工具中提供了hugo的安装，在这里我们推荐使用scoop进行安装 scoop install hugo # 或者安装hugo-extended scoop install hugo-extended 也可以使用Chocolatey进行安装 choco install hugo -confirm # or choco install hugo-extended -confirm 最近windows 中自带的包管理winget 终于转正，迎来了1.0版本，不过首批提供的1400个软件中并没有hugo，还是挺遗憾的。 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:1:2","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"使用源代码进行安装 使用源代码构建需要Git和 Go (版本不低于 Go 1.11)，，然后执行如下脚本就可以进行安装： mkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended 如果不需要Sass/SCSS等功能，可以去除–tags extende语句 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:1:3","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"新建一个站点 安装完成后，我们就可以新建第一个站点，首先进入你预先设定存放站点文件的目录，执行指令: hugo new site [your site name] 执行完成后，hugo会新建一个和站点同名的文件夹。进入目录,，文件结构如下： ├─archetypes ├─content ├─data ├─layouts ├─static └─themes 其中content是存放我们写作的文件的地方，static是存放站点相关静态文件的地方，例如图片，样式表等，themes是存放主题的地方，任何一个hugo站点，没有主题是无法完成构建，也就是无法看到效果的，所以我们首先需要安装一个主题。 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:1:4","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"安装Introdution主题 进入Hugo Themes (gohugo.io)可以查看所有的Hugo主题，选择一个即可。大部分的主题都实现了开箱即用，并且有着完善的教程，经过挑选，我选中了Hugo Theme Introduction )这一款主题，引用主题主页的介绍，该主题有如下优点： 多语言支持，官方支持英语，法语，德语，中文等多种语言 使用Markdown自定义页面 有一个展示项目的模块，还有博客功能 页面有着平滑的加载和跳转动画（确实是一个比较好的优点，很多主题需要自己添加插件） 通过config.toml直接定制功能 贯穿始终的Markdown风格，包括文章标题 支持代码高亮（代码高亮效果一言难尽） 其中的项目展示功能，优秀的动画系统让，我选择了这个主题，另外该主题还自动适配了黑暗模式，体验很好 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:2:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"准备 安装本主题需要hugo-extend版本，另外需要在系统上全局安装一些npm包用于编译scss npm i -g postcss postcss-cli autoprefixer 📌安装完成后，如果执行hugo server运行正常，但是执行构建报如下错误： Error: Error building site: POSTCSS: failed to transform \"css/main.css\" (text/css): resource \"sass/sass/style...\" not found in file cache 可以参考：CSS build issues · Issue #210 · victoriadrake/hugo-theme-introduction ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:2:1","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"安装主题 安装完成后可以进入你站点的根目录，安装主题 git clone https://github.com/victoriadrake/hugo-theme-introduction.git themes/introduction clone完成后，主题安装在站点目录的themes/introduction里，hugo的主题中均包含一个示例站点，在站点目录执行如下指令查看示例站点： cd themes/introduction/exampleSite/ hugo serve --themesDir ../.. 展示站点效果可以查看本站首页 配置 修改站点配置可以使用主题所设置的自定义功能，也可以设置站点的信息等，站点配置文件位于config.toml文件中 点击查看本站完整的站点配置，关键位置均有注释 publishdir = \"docs\" baseURL = \"https://radish.cloud/\" # Your domain name. Must end with \"/\" theme = \"introduction\" DefaultContentLanguage = \"cn\" # Default language for multilingual sites # disqusshortname = \"\" # https://gohugo.io/content-management/comments # googleAnalytics = \"\" # https://gohugo.io/templates/internal/#google-analytics [params] themeStyle = \"auto\" # Choose \"light\" or \"dark\" or \"auto\" favicon = \"/img/fav.ico\" # Path to favicon file showRSSButton = true # Show rss button in navigation fadeIn = true # Turn on/off the fade-in effect fadeInIndex = false # Turn on/off the fade-in effect on the index page even if fade-in was otherwise turned off dateFormat = \"Jan 2, 2006\" email = \"mx@radish.cloud\" # E-mail address for contact section customCSS = [\"foo.css\"] # Include custom css files placed under assets/ # customJS = [\"foo.js\"] # Include custom JavaScript files placed under assets/ # plausible = true # Use Plausible analytics (requires an account at Plausible.io) toc = true # autoCollapseToc = true [params.utteranc] enable = true repo = \"Lairdkin/blog\" # 存储评论的Repo，格式为 owner/repo issueTerm = \"pathname\" # 表示你选择以那种方式让github issue的评论和你的文章关联可以选择默认的pathname。 theme = \"preferred-color-scheme\" # Configure the home page [params.home] introHeight = \"fullheight\" # Input either \"medium\" or \"large\" or \"fullheight\" showLatest = true # Show latest blog post summary showAllPosts = false # Set true to list all posts on home page, or set false to link to separate blog list page allPostsArchiveFormat = true # show all posts in an archive format numberOfProjectsToShow = 3 # Maximum number of projects to show on home page. Unset or comment out to show all projects localTime = true # Show your current local time in contact section timeZone = \"Asia/Shanghai\" # Your timezone as in the TZ* column of this list: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones timeFormat = \"zh-CN\" # Language specific format to use [params.projects] useTwoColumns = false # Use a layout with two columns instead of three # Share buttons on blog post pages [params.share] twitter = true facebook = true pinterest = true # Social icons appear in introduction and contact section. Add as many more as you like. # Icon pack \"fab\" includes social network icons, see: https://fontawesome.com/icons?d=gallery\u0026s=brands\u0026m=free # Icon pack \"fas\" includes solid style icons, see: https://fontawesome.com/icons?d=gallery\u0026s=solid\u0026m=free [[params.social]] url = \"https://twitter.com/menxin74\" icon = \"twitter\" # icon name without the 'fa-' icon_pack = \"fab\" [[params.social]] url = \"https://t.me/radishcloud\" icon = \"telegram\" # icon name without the 'fa-' icon_pack = \"fab\" [[params.social]] url = \"https://github.com/RadishKin\" icon = \"github\" # icon name without the 'fa-' icon_pack = \"fab\" [[params.social]] url = \"https://weibo.com/1910759497\" # For a direct email link, use \"mailto:test@example.org\". icon = \"weibo\" # icon name without the 'fa-' icon_pack = \"fab\" [[params.social]] url = \"https://discord.gg/z3nEreaJvk\" icon = \"discord\" # icon name without the 'fa-' icon_pack = \"fab\" html_attributes = \"rel=\\\"me\\\"\" # Add rel attribute for Mastodon profile link verification [taxonomies] tag = \"tags\" series = \"series\" [markup] defaultMarkdownHandler = \"goldmark\" [markup.goldmark] [markup.goldmark.renderer] unsafe = true [markup.highlight] codeFences = true guessSyntax = true hl_Lines = \"\" lineNoStart = 1 lineNos = true lineNumbersInTable = false noClasses = true # For styles, see https://xyproto.github.io/splash/docs/longer/all.html style = \"monokai\" tabWidth = 4 [languages] [languages.en] languageName = \"English\" languageCode = \"e","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:2:2","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"新建站点文件 主题的首页，是对应语言文件夹中的/home目录,默认的主页需要新建about.md,contact.md,index.md三个文件，分别对应首页的about，contact两个模块，以及最上面的标题部分。 index.md的tittle属性，为对应站点的名称，正文部分为站点的附标题，示例如下： --- title: \"无名博客\" date: 2021-05-28T01:53:59+08:00 --- Anonymous blog \u003c/br\u003e 匿名\u003cruby\u003e\u003crb\u003eブログ\u003c/rb\u003e\u003crt\u003eblog\u003c/rt\u003e\u003crp\u003e(blog)\u003c/rp\u003e\u003c/ruby\u003e contact和index的title属性，是对应板块在导航栏的名称， ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:2:3","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"编译站点 修改完成配置后就可以可以编译静态站点了，首先在配置文件中添加publishdi = \"docs\"配置，编译生成的文件会默认放在站点根目录的/docs目录中，该目录是github pages的默认目录，方便后面部署。 保存配置文件后执行 hugo 即可生成站点文件 其中docs/就是hugo生成的静态站点文件 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:2:4","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"部署博客 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:3:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"部署github pages ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:3:1","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"部署nginx服务器 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:3:2","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"部署cdn为站点加速 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:3:3","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"为博客添加评论 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:4:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"私有部署评论服务 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:5:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"主题功能修改 ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:6:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":["日志"],"content":"TODO 添加博客邮件订阅功能，参见 博客利器：使用 mailchimp 将 RSS 转为邮件订阅 - 少数派 (sspai.com) ","date":"2021-05-30","objectID":"/posts/blog-rebirth-record/:7:0","tags":["hugo","前端技术"],"title":"博客重生小记","uri":"/posts/blog-rebirth-record/"},{"categories":null,"content":"\r","date":"2021-05-29","objectID":"/links/:0:0","tags":null,"title":"友情链接","uri":"/links/"},{"categories":null,"content":"好兄弟们 \rAnhlaidh的博客\r\"不想当写手的码农不是好咸鱼_(xз」∠)_\"\r\r\r\r\r萝卜炖鱼丸的博客\r\"大家要好好吃饭\"\r\r\r\r","date":"2021-05-29","objectID":"/links/:1:0","tags":null,"title":"友情链接","uri":"/links/"},{"categories":null,"content":"我的服务 ","date":"2021-05-29","objectID":"/links/:2:0","tags":null,"title":"友情链接","uri":"/links/"},{"categories":null,"content":"网页服务 一些我部署的常用服务 \rrsshub服务\r\"一个开源、简单易用、易于扩展的 RSS 生成器\"\r\r\r\r\rgithub加速服务\r\"为你的github加速\"\r\r\r\r\r网页代理服务\r\"使用jsproxy访问被屏蔽的网站\"\r\r\r\r\rutterances评论\r\"基于github的博客评论系统，部署于cfworkers\"\r\r\r\r\rTiny Tiny RSS服务\r\"自建rss阅读服务\"\r\r\r\r","date":"2021-05-29","objectID":"/links/:2:1","tags":null,"title":"友情链接","uri":"/links/"},{"categories":null,"content":"Telegram频道 一些我维护的tg频道 \r豆瓣购物优惠推送频道\r\"豆瓣购物优惠快报\"\r\r\r\r\r明日方舟咨讯频道\r\"明日方舟官方信息与同人图\"\r\r\r\r","date":"2021-05-29","objectID":"/links/:2:2","tags":null,"title":"友情链接","uri":"/links/"},{"categories":null,"content":"主题 本站主题源自Hugo-LoveIt，感谢本主题的开发者们！ \rdillonzq / LoveIt\r\"Hugo-LoveIt主题\"\r\r\r\r ","date":"2021-05-29","objectID":"/links/:3:0","tags":null,"title":"友情链接","uri":"/links/"},{"categories":null,"content":"本站的友链信息 name=\"萝卜炖鱼丸的博客\" url=\"https://radish.cloud\" logo=\"https://radish.cloud/images/avatar.jpg\" word=\"大家要好好吃饭\" 如何交换友链 请在本页评论区里添加如下格式，添加友链成功后会通过回复评论的邮件通知进行反馈，所以请在评论时填写正确的邮件地址： //必填项 name=\"站点名字\" url=\"站点地址\" logo=\"站点图标或个人头像\" word=\"站点描述\" 友链须知 上述的友链格式请使用英文的双引号。 若您的头像无法获取时，会自动使用默认头像。 当您的网站存在无法访问、404、友链入口难以发现、删除本站友链等情况时，本站可能会在不通知的情况下撤掉贵站链接！如需恢复需要再次申请。 ","date":"2021-05-29","objectID":"/links/:4:0","tags":null,"title":"友情链接","uri":"/links/"},{"categories":null,"content":"\r\r\rnew Artitalk({\rappId: 'nzQD1VSNO15t41r81iycjyxG-gzGzoHsz', // Your LeanCloud appId\rappKey: 'IsoxHJmeJAdEAei7Sa8ieCXX' // Your LeanCloud appKey\r,serverURL: 'https://comment.radish.cloud'\r})\r\r","date":"2021-05-29","objectID":"/weibo/:0:0","tags":null,"title":"微言","uri":"/weibo/"},{"categories":["笔记"],"content":"转载自 ： {% blockquote 哎呦AU的博客 https://www.cnblogs.com/aurum324/p/8167996.html POJO,JAVABEAN,Entity区别 %} {% endblockquote %} ","date":"2018-05-28","objectID":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/:0:0","tags":["java","JavaEE"],"title":"[转载]POJO,JAVABEAN,Entity区别","uri":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/"},{"categories":["笔记"],"content":"1、javaBean javaBean是一种Java语言写成的可重用组件。为写成JavaBean，类必须是具体和公共的，并且具有无参数的构造器。JavaBean通过提供符合一致性设计模式的公共方法将内部域暴露成员属性。更多的是一种规范，即包含一组set和get方法的java对象。javaBean可以使应用程序更加面向对象，可以把数据封装起来，把应用的业务逻辑和显示逻辑分离开，降低了开发的复杂程度和维护成本。 ","date":"2018-05-28","objectID":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/:0:1","tags":["java","JavaEE"],"title":"[转载]POJO,JAVABEAN,Entity区别","uri":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/"},{"categories":["笔记"],"content":"2、ejb 即EnterpriseBean，也就是Enterprise JavaBean（EJB）。 ejb是JavaEE的一部分，定义了一个用于开发基于组件的企业多重应用程序标准。它被称为Java企业Bean，是java的核心代码，分别是回话Bean（Session Bean）、实体Bean（Entity Bean）、和消息驱动Bean（MessageDriven Bean）。 ","date":"2018-05-28","objectID":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/:0:2","tags":["java","JavaEE"],"title":"[转载]POJO,JAVABEAN,Entity区别","uri":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/"},{"categories":["笔记"],"content":"3、pojo （Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。 其中有一些属性及其getter、setter方法的类，没有业务逻辑，有时可以作为VO（value-object）或DTO（Data Transfer Object）来使用。不允许有业务方法，也不能携带connection之类的方法。 与javaBean相比，javaBean则复杂很多，JavaBean是可复用的组件，对JavaBean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于JavaBean是被容器创建的，所以JavaBean应具有一个无参的构造器。另外，通常JavaBean还要实现Serializable接口用于实现Bean的持久性。一般在web应用程序中建立一个数据库的映射对象时，我们只能称他为POJO。用来强调它是一个普通的对象，而不是一个特殊的对象，其主要用来指代哪些没有遵从特定的java对象模型、约定或框架（如EJB）的java对象。理想的将，一个POJO是一个不受任何限制的java对象 ","date":"2018-05-28","objectID":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/:0:3","tags":["java","JavaEE"],"title":"[转载]POJO,JAVABEAN,Entity区别","uri":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/"},{"categories":["笔记"],"content":"4、entity 实体bean，一般是用于ORM对象关系映射，一个实体映射成一张表，一般无业务逻辑代码。 负责将数据库中的表记录映射为内存中的Entity对象，事实上，创建一个EntityBean对象相当于创建一条记录，删除一个EntityBean对象会同时从数据库中删除对应记录，修改一个Entity Bean时，容器会自动将Entity Bean的状态和数据库同步。 ","date":"2018-05-28","objectID":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/:0:4","tags":["java","JavaEE"],"title":"[转载]POJO,JAVABEAN,Entity区别","uri":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/"},{"categories":["笔记"],"content":"5 、DTO 数据传输对象（Data Transfer Object）。是一种设计模式之间传输数据的软件应用系统。数据传输目标往往是数据访问对象从数据库中检索数据 ","date":"2018-05-28","objectID":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/:0:5","tags":["java","JavaEE"],"title":"[转载]POJO,JAVABEAN,Entity区别","uri":"/posts/pojo-javabean-entity%E5%8C%BA%E5%88%AB/"},{"categories":["笔记"],"content":"转载自 ： {% blockquote 落落无伤的博客 https://www.cnblogs.com/qianqian528/p/8032098.html 常用数据库 JDBC URL 格式 %} {% endblockquote %} ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:0:0","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"一 常用数据库 JDBC URL 格式 ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:1:0","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"1 sqLite 驱动程序包名：sqlitejdbc-v056.jar 驱动程序类名: org.sqlite.JDBC JDBC URL: jdbc:sqlite:c:\\*.db 默认端口 无 ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:1:1","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"2 Microsoft SQL Server Microsoft SQL Server JDBC Driver 驱动程序包名：msbase.jar mssqlserver.jar msutil.jar 驱动程序类名: com.microsoft.jdbc.sqlserver.SQLServerDriver JDBC URL: jdbc:microsoft:sqlserver://\u003cserver_name\u003e:\u003cport\u003e 默认端口1433，如果服务器使用默认端口则port可以省略 ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:1:2","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"3 Oracle Oracle Thin JDBC Driver 驱动程序包名：ojdbc14.jar 驱动程序类名: oracle.jdbc.driver.OracleDriver JDBC URL: jdbc:oracle:thin:@//\u003chost\u003e:\u003cport\u003e/ServiceName 或 jdbc:oracle:thin:@\u003chost\u003e:\u003cport\u003e:\u003cSID\u003e ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:1:3","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"4 IBM DB2 IBM DB2 Universal Driver Type 4 驱动程序包名：db2jcc.jar db2jcc_license_cu.jar 驱动程序类名: com.ibm.db2.jcc.DB2Driver JDBC URL: jdbc:db2://\u003chost\u003e[:\u003cport\u003e]/\u003cdatabase_name\u003e ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:1:4","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"5 MySQL MySQL Connector/J Driver 驱动程序包名：mysql-connector-java-x.x.xx-bin.jar 驱动程序类名: com.mysql.jdbc.Driver JDBC URL: jdbc:mysql://\u003chost\u003e:\u003cport\u003e/\u003cdatabase_name\u003e 默认端口3306，如果服务器使用默认端口则port可以省略 MySQL Connector/J Driver 允许在URL中添加额外的连接属性 jdbc:mysql://\u003chost\u003e:\u003cport\u003e/\u003cdatabase_name\u003e?property1=value1\u0026property2=value2 注意： 需要操作记录为了避免乱码应该加上属性 useUnicode=true\u0026characterEncoding=utf8 ，比如 jdbc:mysql://192.168.177.129:3306/report?useUnicode=true\u0026characterEncoding=utf8 ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:1:5","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"二 Hibernate 中数据库的方言 ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:2:0","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"1 Oracle 方言 org.hibernate.dialect.OracleDialect ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:2:1","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"2 MySQL方言 org.hibernate.dialect.MySQLDialect 3 SQLServer方言 org.hibernate.dialect.SQLServerDialect ","date":"2018-05-28","objectID":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/:2:2","tags":["java","JDBC"],"title":"[转载]常用jdb_curl格式","uri":"/posts/%E5%B8%B8%E7%94%A8jdbcurl%E6%A0%BC%E5%BC%8F/"},{"categories":["笔记"],"content":"如今，如果你作为一个开发者而不知道容器化技术，那你可能要反思一下自己了，作为计算机领域发展最快最热门的技术之一，容器成为了现代互联网服务架构的基石。 2013年DotCloud发布了容器服务Docker，并在2015年发布了其第一个正式版本，同年国内的Daocloud和灵雀云等公司开始提供基于docker的云服务业务，正是在此机会下我有幸接触了当时还非常先进的容器化技术（其实我当时对容器化还没有任何概念）。Docker在当时给我留下了最大的印象就是启动快，部署非常快，并且我当时参照daocloud官方提供的教程构建了一些镜像，不过当时的我，只是把Docker作为了一种新奇好玩的玩具，而没有深入的了解和使用。 时间转到今天，随着微服务的兴起，容器化技术已经成为了微服务架构中的重要基石，docker对我来说不再是一个玩具，而是重要的开发部署工具，从今天起，我将重新开始学习docker,并用一系列文章来记录我学习过程。 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:0:0","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Docker 概述 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:1:0","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"什么是Docker 虽然Docker及其背后代表的容器化技术已经非常热门了，但是容器化并不是什么新技术，于1979年出现的Chroot Jailb被认为是Dcoker技术的起源，也就是现代Linux系统中的chroot环境，下面列出的一些都是早期的容器服务： Chroot Jail FreeBSD Jails Linux VServer Solaris Containers OpenVZ Process Containers LXC Warden LMCTFY Docker RKT 正如我们所看到的，docker 并不是第一个容器化技术，但它的确是最知名的一个。Docker 诞生于 2013 年，并获得了快速的发展。 所以到底什么是Docker呢？ 我们看看书本上的说法： Docker使用Google公司推出的Go语言进行开发实现，基于 Linux内核的cgroup，namespace，以及AUFS类的Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于LXC，从0.7以后开始去除LXC，转而使用自行开发的libcontainer，从1.11开始，则进一步演进为使用runC和containerd。 Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 实际上docker本质上就是一种虚拟化技术，与传统的虚拟化技术不同的是，他没有在虚拟化环境中虚拟出一个完整的操作系统内核，而是将虚拟化环境中的进程放在物理机内核中执行,这就是docker容器化的核心。这种方式使docker具有了很多传统虚拟化方式没有的优势。 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:1:1","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"为什么选择docker 更高效的利用系统资源 由前文我们知道，dcoker容器内的程序本质上就是宿主机上运行的进程，这样就极大减小了性能的损耗，由于不需要模拟内核和周边硬件，也节省了这部分的性能损耗 更快的启动时间 docker容器本质就是一个个宿主机内核程序，所以启动较快 运行环境一致性 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性 持续交付和部署 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署(Continuous Delivery/Deployment) 系统进行自动部署。 更轻松的维护和拓展 Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:1:2","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Docekr的镜像与容器 首先我们了解三个Docker的基本概念 镜像（Image） 容器（Container） 仓库（Repository） 这三个概念组成了Docker的完整生命周期，我们将在下面的过程中详细介绍 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:2:0","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"环境 如今，Docker可以运行在所有的主流操作系统上，包括Linux，Windows，MacOSX，因为我平时喜欢使用Linux，本文将在Linux上部署和使用，我将使用我的笔记本电脑和一台Daocloud胶囊主机来完成本文的内容 本地环境：Manjaro Linux18.0+Docker18.09.0-ce, 远程主机环境：Ubuntu14.04+(因为写作到这的时候断网了就放弃远程环境了) 在Manjaro安装Docker非常简单，在终端输入： sudo Pacman -S docker-ce 即可安装，并无需额外配置 启动Docker服务 systemctl start docker 检查Docker版本 $ docker --version Docker version 18.09.0-ce, build 4d60db472b Docker就安装好了 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:2:1","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"镜像 首先我们将了解Docker最核心的概念之一：镜像。镜像是Docker特殊的文件存储形式，其中储存了Linux运行时的用户空间，根据Linux的设计，Linux分为内核和用户空间，宿主机为Docker容器运行提供了内核支持，而Linux镜像为Docker运行提供了用户空间的支持。除了Linux的用户空间外，Docker镜像还储存了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等），Docker镜像不包含任何动态数据，构建完成后不会被改变。 由于docker使用了UnionFS技术，所以Docker实现了分层储存的特性，镜像并非是一个完整的“镜像”文件，而是一种抽象概念，在存储中，Docker镜像根据构建顺序依次完成储存，不同的镜像可以共享其中的中间层，大大减小了Docker镜像的体积。 获取镜像 Docker运行前需要对应的镜像，所以我们可以从镜像仓库拉取镜像，Docker默认的镜像仓库是DockerHub，其中内置了大量高质量的Dokcer基础镜像，我们也可以将自己的镜像发布至DockerHub 前文我们提到了仓库（Repository）的概念，仓库是一个集中存储和分发镜像的服务，一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。我们可以部署只自己仓库，也可以使用公共的仓库服务。 获取镜像使用docker pull命令： docker pull [选项] [Docker Registry地址]\u003c仓库名\u003e:\u003c标签\u003e 如没有仓库地址名，将使用默认的仓库。 例如： $ sudo docker pull node:latest latest: Pulling from library/node 54f7e8ac135a: Already exists d6341e30912f: Already exists 087a57faf949: Already exists 5d71636fb824: Pull complete 0c1db9598990: Pull complete 89669bc2deb2: Pull complete 647616206038: Pull complete 64f67f03205b: Pull complete Digest: sha256:fed3f48ec9e97a57c17977ff120c3e7bf7d2d4e930ef650bba3f2ada5ac4a33a Status: Downloaded newer image for node:latest 这个命令将在Docker的中央仓库下载一个最新版本的Nodejs镜像 列出镜像 我们可以使用docker images列出所有本地的镜像 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker-test 0.0.1 ce25b22437c5 9 days ago 443MB node latest 37f455de4837 9 days ago 894MB tomcat latest 48dd385504b1 9 days ago 475MB ubuntu latest 93fd78260bd1 3 weeks ago 86.2MB fabric8/java-jboss-openjdk8-jdk 1.2.3 7a2a8001c977 23 months ago 422MB 列表包含了仓库名、标签、镜像 ID、创建时间以及所占用的空间。 docker分层构建的方式产生了大量的中间层镜像，docker默认只显示最外层的镜像，我们可以通过以下命令查看 $ docker images -a 此外docker images还可以通过一些条件来查看镜像： # 查看特定仓库名的镜像 $ sudo docker images ubuntu REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 93fd78260bd1 3 weeks ago 86.2MB # 使用过滤器查看镜像 # 从某个镜像开始的所有镜像 sudo docker images -f since=ubuntu # 查看特点标签的镜像 docker images -f label=com.example.version=0.1 # 使用Go语言模板制定输出格式 $ docker images --format \"table {{.ID}}\\t{{.Repository}}\\t{{.Tag }}\" 删除镜像 当我们不需要某个镜像的时候，我们可以选择删除镜像，使用docker rmi命令即可删除镜像 例如： $ sudo docker rmi tomcat:latest 构建镜像 使用DockerFile构建镜像将在下一篇文章中详细展开 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:2:2","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"容器 如果你熟悉面向对象的开发的话，你可能更容易理解镜像与容器之间的关系。镜像就是面向对象中的类，而容器就是实例，容器就是实例化的镜像，容器是动态的。如前文所述，容器的实质是宿主机中的进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间,容器内的进程是隔离与宿主机环境的。 运行 当我们有了镜像之后，我们就可以运行我们的镜像并建立新的容器（实例）,docker使用docker run 命令来运行容器 $ sudo docker run -it --rm ubuntu /bin/bash root@d332f4d5aecb:/# cat /etc/os-release NAME=\"Ubuntu\" VERSION=\"18.04.1 LTS (Bionic Beaver)\" ID=ubuntu ID_LIKE=debian PRETTY_NAME=\"Ubuntu 18.04.1 LTS\" VERSION_ID=\"18.04\" HOME_URL=\"https://www.ubuntu.com/\" SUPPORT_URL=\"https://help.ubuntu.com/\" BUG_REPORT_URL=\"https://bugs.launchpad.net/ubuntu/\" PRIVACY_POLICY_URL=\"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\" VERSION_CODENAME=bionic UBUNTU_CODENAME=bionic root@d332f4d5aecb:/# exit exit –it ：这是两个参数，一个是 -i ：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终获取镜像终端。 –rm ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。 ubuntu:14.04 ：这是指用 ubuntu:14.04 镜像为基础来启动容器。 /bin/bash ：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash 。 当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从公有仓库下载 启动 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 我们可以使用-d参数使容器在后台运行，例如： $ sudo docker run -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a 使用docker ps 可以查看docker容器运行状态 $ sudo docker ps 希望获取docker日志信息 docker logs 77b2dc01 终止容器 当我们需要终止容器时可以使用docker stop 命令,当容器z中的应用终止时，容器也会自动终止，可以使用docker ps -a 查看中止的容器，终止的容器可以用docker start来重新启动,同理，docker restart 将会将容器重启 删除容器 可以使用 docker rm 来删除一个处于终止状态的容器。 例如 $sudo docker rm trusting_newton trusting_newton 如果要删除一个运行中的容器，可以添加-f参数。Docker 会发送 SIGKILL 信号给容器。 使用如下命令可以终结全部处于终止状态的容器 docker rm $(docker ps -a -q) 其他操作 导出容器 如果要导出本地某个容器，可以使用 docker export 命令。 $ sudo docker export 3f6\u003ejava.tar 导入容器 导出的本地镜像可以用docker import命令来导入 cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0 下一篇文章，我们讲讲解docker构建镜像的常见方式 参考 杨保华,戴王剑，曹亚伦-Docker技术入门与实战第二版 alonghub-Docker的发展历程 ","date":"2018-05-28","objectID":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/:2:3","tags":["docker","java"],"title":"Docker入门笔记（一）","uri":"/posts/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"最近记性实在是下降的厉害，搞的东西天天忘，所以把咕了好几年的博客又捡起来了，这次选用了Hexo作为博客的引擎，支持markdown，轻量，部署简单，不过安装中还是踩了一些坑，简单的记录下（其实就是博客太空水一篇2333 \rfetch(\"https://demo.radishkin.workers.dev/api/set?url=\"+window.btoa(location.href)).then(res={\rconsole.log(res)\r})\r\r","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"环境 服务器：阿里云学生机 轻量级应用服务器 服务器系统：Ubuntu16.04 阿里云一直不提供1804的镜像，但是不推荐手动升级，容易挂 本地系统：Manjaro 18.0 Illyria ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:0","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"部署 Hexo生成的是纯静态页面，所以部署只需将hexo生成的public目录放置在 nginx 站点目录下就可以 ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:0","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"Hexo 安装 安装Hexo 前确保系统有以下软件： Node.js Git 因为Ubuntu源中提供的nodejs版本非常老，所以我们使用官网提供的一个安装方式来安装nodejs # Using Ubuntu curl -sL https://deb.nodesource.com/setup_11.x | sudo -E bash - sudo apt-get install -y nodejs # Using Debian, as root curl -sL https://deb.nodesource.com/setup_11.x | bash - apt-get install -y nodejs 这个脚本会自动识别系统版本并添加ppa源 然后 # 安装git sudo apt install git 因为我们是在服务器端调用hexo生成静态页面，所以本地只需要安装git就可以 # manjaro 安装git sudo pacman -S git # 也可以在本地安装nodejs，方便调试 sudo pacman -S nodejs 然后安装hexo npm install -g hexo-cli 测试一下 hexo -v 输出 hexo-cli: 1.1.0 os: Linux 4.19.1-1-MANJARO linux x64 http_parser: 2.8.1 node: 11.1.0 v8: 7.0.276.32-node.7 uv: 1.23.2 zlib: 1.2.11 ares: 1.15.0 modules: 67 nghttp2: 1.34.0 napi: 3 openssl: 1.1.1 icu: 63.1 unicode: 11.0 cldr: 34.0 tz: 2018e Hexo 安装完毕 ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:1","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"Hexo新建站点和基本配置 选择一个存放站点文件的目录，执行 hexo init “站点名” hexo会在当前目录下新建一个站点文件夹，cd进站点文件夹，执行 npm install 执行完成后，生成目录如下 $ tree blog blog ├── _config.yml ├── db.json ├── node_modules ├── package.json ├── package-lock.json ├── scaffolds ├── source └── themes 其中_config.yml是整个站点的配置文件，source是存放文章来源的md文件的，package.json存放了站点的依赖，theme是主题文件 在站点文件夹内，使用 hexo g 生成静态文件，静态文件存放在该目录的public/下 然后编辑_config.yml # 站点基本信息title:#站点名称subtitle:#子标题description:keywords:author:language:zh-cn#语言设置为简体中文timezone:# 站点链接配置url:http://ljmx.toproot:/permalink::year/:month/:title.htmlpermalink_defaults:# 一些默认文件的配置source_dir:sourcepublic_dir:publictag_dir:tagsarchive_dir:archivescategory_dir:categoriescode_dir:downloads/codei18n_dir::langskip_render:# 使用hexo new 时写作模板# 因为平时都是直接新建md文件，所以这里一般都用不上QAQ# new_post_name::title.md# File name of new postsdefault_layout:posttitlecase:false# Transform title into titlecaseexternal_link:true# Open external links in new tabfilename_case:0render_drafts:falsepost_asset_folder:falserelative_link:falsefuture:truehighlight:enable:trueline_number:trueauto_detect:falsetab_replace:# 主页设定，这个一般根据主题来修改index_generator:path:''per_page:10order_by:-date# 标签default_category:uncategorizedcategory_map:tag_map:#日期格式date_format:YYYY-MM-DDtime_format:HH:mm:ss# 分页per_page:10pagination_dir:page# 拓展，主题和插件## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme:anatole# Deployment## Docs: https://hexo.io/docs/deployment.html# 自动部署配置，没用过2333deploy:type: 然后可以选择一个自己喜欢的主题，放到/theme 文件夹里，在配置文件theme行写上主题名称，生成文件即可更换主题 我们使用的主题依赖 hexo-render-pug插件，所以启用前需要执行 npm install hexo-render-pug --save安装，才能正常渲染 ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:2","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"Nginx 配置 ubuntu1604 安装nginx sudo apt install nginx 查看服务状态 service nginx status Active状态显示 active证明配置正常 编辑/etc/nginx/nginx.conf #修改第一行，变更nginx执行权限，其实不推荐这样做，应该修改文件的访问权限，但是我懒233 user root #增加一下一行到文件中 include /etc/nginx/conf.d/*.conf; 然后在/etc/nginx/conf.d目录中新建一个站点名.conf的文件，编辑这个文件 server { listen 4000; # 监听端口 server_name ljmx.top; # 站点域名 root /var/www/public; # 站点根目录,指向自己站点的public文件夹 index index.html index.htm index.php; # 默认导航页 } 重启nginx service nginx restart ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:3","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"webhook实现自动部署 现在博客部署好了，但是我每次写完文章，push到github，然后登录服务器，pull下来，执行生成语句，这样比较繁琐，所以我们的webhook就登场了 webhook是git上的一个服务，他提供了一种能力，当仓库发生变动时，webhook会自动post一段信息到预先设定的地址。通过这种方式，我们可以实现自动化生成和部署博客 在github项目主页中，点击setting\u003ewebhooks，然后ADD一个新的webhook，Payload URL填写服务器ip+端口号+请求路径，请求类型选json，sceret随便生成，但是要记住。 在hexo站点根目录下新建一个叫webhook.js文件， 填入以下内容: var http = require('http') var createHandler = require('github-webhook-handler') var handler = createHandler({ path: '/webhooks_push', secret: '' }) // 上面的 secret 保持和 GitHub 后台设置的一致 function run_cmd(cmd, args, callback) { var spawn = require('child_process').spawn; var child = spawn(cmd, args); var resp = \"\"; child.stdout.on('data', function(buffer) { resp += buffer.toString(); }); child.stdout.on('end', function() { callback (resp) }); } handler.on('error', function (err) { console.error('Error:', err.message) }) handler.on('push', function (event) { console.log('Received a push event for %s to %s', event.payload.repository.name, event.payload.ref); run_cmd('sh', ['./deploy.sh'], function(text){ console.log(text) }); }) try { http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404 res.end('no such location') }) }).listen(6000) //可以在这修改监听端口号 }catch(err){ console.error('Error:', err.message) } 在目录下新建一个deploy.sh的文件，填入以下内容 #填入markdown文件所在位置 cd /root/website/myblog/source git reset --hard git pull origin master hexo generate 然后安装依赖： npm install github-webhook-handler --save 运行 node webhook.js 可以使用pm2，或者nohup等方式守护进程 这样当提交pull request的时候，服务器就会自动生成静态文件并部署了 ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:4","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"其他 因为时间匆忙（其实就是懒，所以很多东西还没有完善，留给下篇博文吧 待完成 修改博客模板 全站ssl 访问统计 资源文件夹 多用户 ","date":"2018-05-28","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:0","tags":["Hexo","nodejs"],"title":"Hexo博客搭建","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["笔记"],"content":"Springboot是由spring开发团队Pivotal推出的全新框架，他设计目的简化繁琐的Spring配置,专注于应用的开发。SpringBoot采用了\"约定优先于配置（COC，Convnetion Over Configuration）“的设计思想，通过为企业开发应用环境设计出了很多自动配置的依赖模块,这些模块几乎不需要配置，开箱即用，极大的简化了开发周期和代码量。 ","date":"2018-05-28","objectID":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:0:0","tags":["java","Springboot"],"title":"Springboot快速上手","uri":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["笔记"],"content":"环境 本文开发环境以写作时的最新版本2.1.0.RELEASE为基准 JDK1.8及以上 Maven 3.2 Tomcat 8及以上 hibernate 5.2以上 使用最新版idea可以快速创建一个springboot项目并初始化一些模块，如果不使用idea，可以新建Maven项目并从官网下载并定制所需组件 ","date":"2018-05-28","objectID":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:0:1","tags":["java","Springboot"],"title":"Springboot快速上手","uri":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["笔记"],"content":"项目Maven依赖 我们使用Maven作为项目的的依赖管理，有关Maven的内容可以查看网上的其他相关信息，下面列出了项目所有使用的模块 继承Springboot的核心依赖 \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.1.0.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e jpa \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e \u003c/dependency\u003e web核心组件 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e mysql ,如果mysql-server版本是8.0需要指明connector版本8.0+ \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e lmbok，减少代码量 \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e Springboot 测试模块，默认使用junit \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e swagger \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e2.2.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e2.2.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2018-05-28","objectID":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:0:2","tags":["java","Springboot"],"title":"Springboot快速上手","uri":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["笔记"],"content":"工程目录结构 然后我们查看下项目生成的默认文件结构 $ tree . ├── mvnw ├── mvnw.cmd ├── pom.xml ├── src │ ├── main │ │ ├── java │ │ │ └── top/ljmx/springboot/demo/demo │ │ │ └── DemoApplication.java │ │ └── resources │ │ ├── application.properties │ │ ├── static │ │ └── templates │ └── test │ └── java │ └── top/ljmx/springboot/demo/demo │ └── DemoApplicationTests.java └── srpingboot-sdemo.iml 18 directories, 7 files src是项目的主文件夹，其中main是主要代码，test是测试代码，这是一个典型的Maven工程的文件结构，pom.xml是Maven的依赖文件。main先分为java和resources，java存放代码，resources存放静态资源，目录中的application.properties是工程的配置文件 Springboot遵循springMVC的分层结构结构，所以我们先在包top.ljmx.springboot.demo.demo下新建以下几个子包 controller 存放所有的控制器代码 model 存放所有的数据模型 repository 存放所有的数据操作 service 业务代码 其他可选包 config 存放配置代码，如swagger util 存放工具类 expection 统一异常处理 ","date":"2018-05-28","objectID":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:0:3","tags":["java","Springboot"],"title":"Springboot快速上手","uri":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["笔记"],"content":"一个简单的Springboot入门实例 本实例参照库米云微王华杰老师课程代码 本实例实现了一套登陆与注册接口，并使用slflog收集日志，并用swagger2提供文档和测试服务 编辑resources目录下的application.properties文件 #tomcat configserver.port = 8080server.tomcat.uri-encoding = utf-8#Mysqlspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver#配置mysql驱动spring.datasource.url = jdbc:mysql://localhost:3306/test?useUnicode=true\u0026characterEncoding=utf8\u0026serverTimezone=GMT%2B8#serverTimezone=GMT%2B8是解决运行中出现f服务器时区无法识别的异常的spring.datasource.username = rootspring.datasource.password = ***********#jpaspring.jpa.database = mysqlspring.jpa.show-sql = truespring.jpa.hibernate.ddl-auto = updatespring.jpa.hibernate.naming.physical-strategy = org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy#数据库方言mysqlspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect 然后在MySQL中新建一个名叫test的数据库 然后先新建一个用户实体类，在model包下新建一个User.java,写入以下内容 package top.ljmx.demo.model; import lombok.Data; import javax.persistence.Entity; import javax.persistence.*; @Entity //声明数据实体类 @Data //产生setter，getter方法 public class User { @Id //标识主键 @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer keyid; private String userName; private String phoneNumber; private String password; } 可以在该类添加@table注解可以指定自动生成的表的类名 然后基于JPA实现DAO层（数据操作层，就是repository包），新建一个UserRepositoty的类，代码如下 package top.ljmx.demo.repositoty; import org.springframework.data.jpa.repository.Query; import top.ljmx.demo.model.User; import org.springframework.stereotype.Repository; import org.springframework.data.jpa.repository.JpaRepository; @Repository public interface UserRepositoty extends JpaRepository\u003cUser,Integer\u003e{ @Query(\"select a from User a where a.phoneNumber=?1\") User getByPhoneNumber(String phoneNumber); } 需要解释的是，Spring Data JPA提供了很多持久层接口，例如Repository,CrudRepositoty,PagingAndSortingRepository 以及JpaRepository 接口。其中Repository为基类，JpaRepository继承自PagingAndSortingRepository接口，两个泛型参数分别代表Java POJO类以及主键数据类型。我们创建自己的数据库操作接口时，只需继承上述JPA提供的某个接口，即可自动继承相关数据操作方法，而不需要再次实现。例如CrudRepositoty提供了对增删改查操作的实现，PagingAndSortingRepository提供了分页查询方法的实现。另外JPA提供了一套命名规则例如readBy()等，这些方法也只需要用户申明而由JPA自动实现了。如果这仍不能满足业务需求，也可以自定义SQL查询语句，例如上述代码所示，采用@Query标签,我们之后将开设单独的一章讲解JPA 最后实现控制器类，在包 controller中新建UserController类 package top.ljmx.demo.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import top.ljmx.demo.model.User; import top.ljmx.demo.repositoty.UserRepositoty; //Spring组合注解,声明Rest接口 @RestController public class UserController { @Autowired //自动装配成员变量 private UserRepositoty userRepositoty; @ApiOperation(value = \"注册\") @RequestMapping(value = \"/user/register\",method = RequestMethod.GET) //地址映射，并指定请求方法 public Object register( @RequestParam(\"username\") String userName, @RequestParam(\"phonenumber\") String phoneNumber, @RequestParam(\"password\") String password){ //参数列表 User user = new User(); user.setUserName(userName); user.setPhoneNumber(phoneNumber); user.setPassword(password); try { userRepositoty.save(user); //实例化对象 }catch (Exception e){ return \"注册失败\"; } return \"注册成功\"; } @RequestMapping(value = \"/user/login\",method = RequestMethod.GET) public Object login(@RequestParam(\"phonenumber\") String phoneNumber, @RequestParam(\"password\") String password){ User user = userRepositoty.getByPhoneNumber(phoneNumber); if (user.getPassword().equals(password)){ return \"登录成功\"; }else { return \"登录失败\"; } } } 这个控制器实现了login和register两个接口,可以模拟简单的登录和注册功能 当我们配置好数据库信息时， 运行main函数，访问http://localhost:8080/user/register?username=mx\u0026phonenumber=1234546\u0026password=123会在数据库中新建一条数据,访问http://localhost:8080/user/login?phonenumber=123454\u0026password=123(数据表里存在的数据)会输出登录正常。 之后的文章会对这个简单的注册登录做更多改进 参考：https://blog.csdn.net/u013248535/article/details/55100979/ ","date":"2018-05-28","objectID":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:0:4","tags":["java","Springboot"],"title":"Springboot快速上手","uri":"/posts/springboot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["笔记"],"content":"想要深入了解JVM，就必须了解其实现机制。了解JVM实现的最好方法便是自己动手编译JDK。本文中，我将参照《深入理解Java虚拟机》中的教程，编译openjdk1.8 ","date":"2018-05-28","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/:0:0","tags":["java","jdk","jvm"],"title":"一次失败的jdk编译","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/"},{"categories":["笔记"],"content":"准备工作 ","date":"2018-05-28","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/:1:0","tags":["java","jdk","jvm"],"title":"一次失败的jdk编译","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/"},{"categories":["笔记"],"content":"系统环境 编译机器：Lenovo RUI7000 (i7-7700hq+8g DDRR4内存) 操作系统：Manjaro i3wm 18.0 ","date":"2018-05-28","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/:1:1","tags":["java","jdk","jvm"],"title":"一次失败的jdk编译","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/"},{"categories":["笔记"],"content":"软件环境 java虚拟机部分大多是C++代码，但类库都是由java写成的，所以编译JDK之前你首先需要有个jdk（嘿嘿，我编译我自己 所以编译环境需要以下依赖程序： bootstrap jdk：jdk1.8或jdk1.7 gcc，g++ 4.4+ (据官网说gcc版本最高只测试到7.4) 执行 sudo pacman -S java-8-openjdk gcc g++ ","date":"2018-05-28","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/:1:2","tags":["java","jdk","jvm"],"title":"一次失败的jdk编译","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/"},{"categories":["笔记"],"content":"下载源码 openjdk团队使用Mercurial工具管理源代码 安装: sudo pacman -S Mercurial 克隆代码 hg clone http://hg.openjdk.java.net/jdk8u/jdk8u/ clone完成后，进入源码目录，执行脚本 bash get_source.sh 会自动获取全部源码 如果下载太慢，可以使用github上的代码镜像 https://github.com/unofficial-openjdk/openjdk/ 注意：直接克隆整个仓库会下载所有版本jdk源码 ","date":"2018-05-28","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/:1:3","tags":["java","jdk","jvm"],"title":"一次失败的jdk编译","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/"},{"categories":["笔记"],"content":"编译 自动生成编译文件并检查依赖 bash ./configure 如果中途中断，请检查输出，安装对应的依赖库 执行编译命令 make all 如果成功会在所在文件夹下生成一个images的文件夹 然后我失败了QAQ 目前知道是遇到了一个已知bug，另外编译环境也炸了hhhh，下篇文章再说吧 咕咕咕 ","date":"2018-05-28","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/:2:0","tags":["java","jdk","jvm"],"title":"一次失败的jdk编译","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91jdk/"},{"categories":["杂谈"],"content":"昨天写Dockerfile那篇文章的时候，发下我的镜像中java有一个启动参数-Djava.security.egd=file:/dev/./urandom，我查了察相关资料，发现了些有趣的事情 ","date":"2018-05-28","objectID":"/posts/%E7%86%B5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/:0:0","tags":["Linux","密码学"],"title":"熵与随机数","uri":"/posts/%E7%86%B5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"categories":["杂谈"],"content":"随机数 关于这个参数，我们从随机数来说起 学过编程的同学应该都接触过随机数这个概念，虽然叫随机，但是大多数随机数生成实质上是通过一定的预先设定的算法计算出来的，根据密码学的原理，随机数的随机性检验有三个标准： 统计学伪随机性:统计学伪随机性指的是在给定的随机比特流样本中，1的数量大致等于0的数量，同理，“10”“01”“00”“11”四者数量大致相等。类似的标准被称为统计学随机性。满足这类要求的数字在人类“一眼看上去”是随机的。 密码学安全伪随机性: 其定义为，给定随机样本的一部分和随机算法，不能有效的演算出随机样本的剩余部分。 真随机性：其定义为随机样本不可重现。实际上只要给定边界条件，真随机数并不存在，可是如果产生一个真随机数样本的边界条件十分复杂且难以捕捉（比如计算机当地的本底辐射波动值），可以认为用这个方法演算出来了真随机数 相应的，随机数也分为三类： 伪随机数：满足第一个条件的随机数。 密码学安全的伪随机数：同时满足前两个条件的随机数。可以通过密码学安全伪随机数生成器计算得出。 真随机数：同时满足三个条件的随机数。 我们平时使用的大多数编程语言中所生成的随机数都是伪随机数，例如java中的Random类，可以使用时间戳作为随机种子，这种随机数足以满足我们大多数对随机数生成的需求，但是在一些特殊场合，例如在线交易中的id（这是区块链安全性中的重要一环，据我所知，有多起区块链攻击行为与区块链生成算法有缺陷有关），对随机数的安全性要求较高时，就要求达到密码学安全的伪随机数甚至真随机数，在java中，有一些提供安全随机数生成算法的类，例如org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom，在Tomcat7/8中，就使用了这个类用来产生seesion id，这个类中有一个种子生成器，他会根据配置来获取随机种子，在Tomcat中，会默认使用/dev/random返回的字符来作为种子，这个/dev/random 就是我们今天的主角。 ","date":"2018-05-28","objectID":"/posts/%E7%86%B5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/:1:0","tags":["Linux","密码学"],"title":"熵与随机数","uri":"/posts/%E7%86%B5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"categories":["杂谈"],"content":"Linux中的熵池 /dev/random是Linux中的一个真随机数生成器，这个生成器维护了一个熵池，Random方法会从熵池中取出字符串作为种子来产生随机数，我们的熵的大部分来于键盘、鼠标和磁盘 IO 数据这样的环境噪声，这些计算机活动所产生的熵会帮助随机数生成，在生成GPG秘钥的过程中，你可能会遇到如下提示： We need to generate a lot of random bytes. It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy. ++++++++++..+++++.+++++++++++++++.++++++++++...+++++++++++++++...++++++ +++++++++++++++++++++++++++++.+++++..+++++.+++++.+++++++++++++++++++++++++\u003e. ++++++++++\u003e+++++...........................................................+++++ Not enough random bytes available. Please do some other work to give the OS a chance to collect more entropy! (Need 290 more bytes) 但是假如我们的系统是一个服务器，我们没有鼠标和键盘输入。这意味着唯一的因素是你的磁盘IO。如果它是一个单独的、几乎不使用的磁盘，你将拥有较低的熵。另外一个问题是/dev/random是阻塞的，当你频繁生成随机数的时候，你可能会耗光你的熵池，/dev/random 会等待熵池收集到足够的环境噪声的时候才会继续生成随机数，这可能导致你的进程被长时间的挂起。在java 开发中，常常会遇到一些应用启动时间过长的问题，就可能是熵池空了导致线程阻塞了。 幸好Linux给我们提供了另外一个随机数生成器来解决这个问题。/dev/unrandom,这是一个伪随机数生成器，在缺乏熵的时候，他会复用熵池中的内容而不会导致阻塞，但是复用熵池会导致安全性下降，但是在安全性不强的情况下，可以考虑使用这个，比如我们可以使用-Djava.security.egd=file:/dev/./urandom这个java启动参数，来确保我们生成随机数的过程不被阻塞，这也回答了我们开头那个问题，java.security.egd是org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom的配置。 我们还可以用一些方法来影响熵池 $ cat /proc/sys/kernel/random/poolsize 4096 $ cat /proc/sys/kernel/random/entropy_avail 2975 使用这两个命令可以查看当前熵池的大小和熵池内有多少熵 我们可以通过一些方法来将熵池耗尽，比如将将/dev/random 定向到/dev/null中 $ cat /dev/random \u003e /dev/null \u0026 这样会快速的将熵池耗尽 如果我们想填充熵池呢，最好的办法是将处理器的抖动加入熵池中，我们可以安装Haveged来实现这一功能 $ sudo pacman -S Hacedged $ systemctl enable haveged $ systemctl start haveged 我们可以通过pv命令来观察熵池的增长速度 # 启用前 $ pv /dev/random \u003e /dev/null 25.0 B 0:00:03 [0.00 B/s] [ \u003c=\u003e # 启用后 $ pv /dev/random \u003e /dev/null 62MiB 0:00:03 [ 564KiB/s] [ \u003c=\u003e 可以观察到从几乎为0增长到了564kiB/s 参考： James J - /dev/[u]random：对熵的解释 chszs - Tomcat 8熵池阻塞变慢详解 ","date":"2018-05-28","objectID":"/posts/%E7%86%B5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/:2:0","tags":["Linux","密码学"],"title":"熵与随机数","uri":"/posts/%E7%86%B5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"categories":null,"content":" \r ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"萝卜炖鱼丸 摸鱼选手，爱好又多又杂，信息管理与信息系统本科生，待业状态，目前方向：Java后端开发 常用名：心灵炼金师，萝卜炖鱼丸，menxin 都是我 代码写的还行选手，前ACM队员，但是没什么拿得出手的奖 常用语言：Java，Python，JavaScript 常驻以下两个游戏 最终幻想14 国服-海猫茶屋-猫小胖 id：萝卜炖鱼丸 明日方舟 官服 id：萝卜炖鱼丸 联络请优先通过Telegram 或者 邮箱联系，其他途径随缘 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"关于我","uri":"/about/"}]